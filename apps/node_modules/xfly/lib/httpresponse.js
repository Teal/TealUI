var FS = require('fs'),	HttpWorkerRequset = require('./httpworkerrequest'),	HttpUtility = require('./httputility'),	HttpCookie = require('./httpcookie'),	HttpCookieCollection = require('./httpcookiecollection');/** * 封装来自服务器操作的 HTTP 响应信息。 * @class */function HttpResponse(httpWorkerRequest, context){	this._wr = httpWorkerRequest;	this.context = context;	this._buffers = [];		this.contentEncoding = httpWorkerRequest.contentEncoding;}HttpResponse.prototype = {	/**	 * 当前对象关联的 {@link HttpWorkerRequest} 对象。	 * @type HttpWorkerRequest	 * @private	 */	_wr: null,		/**	 * 当前对象的输出缓存对象。	 * @type Buffer[]	 * @private	 */	_buffers: null,		_statusCode: 200,		_statusDescription: null,		_raiseHeaderWrittenException: function(){		throw new Error('Can\'t set headers after they are sent.');	},		_writeHeaders: function(finalFlush){				var headers = this._headers || Object,			wr = this._wr;				// 发送 Http 状态。		wr.sendStatus(this.statusCode, this.statusDescription);				// 发送预定义的头。		for(var key in headers){			wr.sendHeader(key, headers[key]);		}				// 如果未发送一些字段，则自动生成。				//if(!('Content-Type' in headers)) {		//	wr.sendHeader('Content-Type', 'text/html; charset=' + this.contentEncoding);		//}				var connection = headers['connection'];		var chunk = false;				// 如果支持缓存，并且是最后一次发送，则生成 Content-Length 并关闭连接。		if(this.bufferOutput && finalFlush){						if(!('content-length' in headers)) {				wr.sendCalculatedContentLength(this._calculateContentLength());			}						if(!connection){				wr.sendHeader('Connection', connection = 'Close');			}						} else if('content-length' in headers){			if(!connection){				wr.sendHeader('Connection', connection = 'Close');			}		} else if(!headers['transfer-encoding']){			chunk = true;			wr.sendHeader('transfer-encoding', "Chunked");						if(!connection){				wr.sendHeader('Connection', connection = "Keep-Alive");			}		} else if(!connection){			chunk = /^chunk$/i.test(headers['transfer-encoding']);			wr.sendHeader('Connection', connection = chunk ? "Keep-Alive" : 'Close');		}				wr.setKeepAlive(!/^close$/i.test(connection), chunk);				if(this._cookies){			wr.sendCookies(this._cookies);		}				// 发送附加隐藏的 Cookie 。比如 Session 。		if(this._externalCookie){			wr.sendHeader('Set-Cookie', this._externalCookie);		}				if(!('date' in headers)) {			wr.sendHeader('Date', utcDate());		}				if(!('server' in headers)) {			wr.sendHeader('Server', wr.getServerName());		}				wr.endOfHeaderSent();				if('expect' in headers) {			wr.sendResponseFromMemory('');		}		},		_calculateContentLength: function(){		for(var i = 0, buffers = this._buffers, len = buffers.length, sum = 0; i < len; i++){			sum += buffers[i].length;		}		return sum;	},		_writeRaw: function(data){		this._buffers.push(data);				if(!this.bufferOutput) {			this.flush();		}	},		/**	 * 获取当前对象关联的 {@link HttpContext} 对象。	 * @type HttpContext	 */	context: null,		// buffer		/**	 * 获取或设置一个值，该值指示是否缓冲输出并在处理完整个响应之后发送它。	 * @returns 如果缓冲了发送给客户端的输出，则为 true；否则为 false。	 */	bufferOutput: true,		/**	 * 获取或设置 Cache-Control HTTP 标头。	 * @return {String} Cache-Control HTTP 标头。	 */	get cacheControl(){		return this.getHeader("Cache-Control");	},		/**	 * 获取或设置 Cache-Control HTTP 标头。	 * @return {String} Cache-Control HTTP 标头。	 */	set cacheControl(value){		this.setHeader("Cache-Control", value);	},		// Charset		/**	 * 获取或设置向客户端输出的内容编码。	 * @type Encoding	 */	contentEncoding: null,		/**	 * 获取或设置输出流的 HTTP MIME 类型。	 * @return {String} 输出流的 HTTP MIME 类型。默认值为"text/html"。	 */	get contentType(){		return this.getHeader("Content-Type") || "text/html";	},		/**	 * 获取或设置输出流的 HTTP MIME 类型。	 * @return {String} 输出流的 HTTP MIME 类型。默认值为"text/html"。	 */	set contentType(value){		//if(/^text\/html/i.test(value) && !/\bcharset\b/i.test(value)){		//	value += '; charset=' + this.contentEncoding;		//}		this.setHeader("Content-Type", value);	},		/**	 * 获取或设置主体的大小。	 * @return {Number} 可以是任何值或 OutputStream 的长度。	 */	get contentLength(){		var value = +this.getHeader("Content-Length");		return isNaN(value) ? -1 : value;	},		/**	 * 获取或设置主体的大小。	 * @return {Number} 可以是任何值或 OutputStream 的长度。	 */	set contentLength(value){		this.setHeader("Content-Length", value.toString());	},		/**	 * 获取或设置传输方式。	 * @return {Boolean}	 */	get chunked(){		var chunk = this.getHeader("Transfer-Encoding");		return chunk ? /^chunked$/i.test(chunk) : false;	},		/**	 * 获取或设置传输方式。	 * @return {Boolean}	 */	set chunked(value){		if(value){			this.setHeader("Transfer-Encoding", 'Chunk');		} else {			this.removeHeader("Transfer-Encoding");		}	},		/**	 * 获取响应 Cookie 集合。	 * @return {HttpCookieCollection} 响应 Cookie 集合。	 */	get cookies(){		return this._cookies || (this._cookies = new HttpCookieCollection());	},		/**	 * 获取指示当前是否存在 Cookie 的值。	 * @return {Boolean} 如果存在 Cookie 则返回 true 。	 */	get hasCookies(){		if(!this._cookies){			return false;		}				for(var key in this._cookies){			if(!this._cookies.hasOwnProperty(key)){				return true;			}		}						return false;	},		/**	 * 获取或设置在浏览器上缓存的页过期之前的分钟数。如果用户在页面过期之前返回同一页，则显示缓存的版本。	 * @return {Integer} 在页过期之前的分钟数。	 */	get expires(){		var value = this.getHeader("Expires");		if(value){			try{				value = new Date(value);				return new Date() - value;			} catch(e){							}		}				return -1;	},	/**	 * 获取或设置在浏览器上缓存的页过期之前的分钟数。如果用户在页面过期之前返回同一页，则显示缓存的版本。	 * @return {Integer} 在页过期之前的分钟数。	 */	set expires(value){		var n = new Date();		n.setMinutes(n.getMinutes() + value);		this.setHeader("Expires", n.toUTCString());	},		/**	 * 获取或设置从缓存中移除缓存信息的绝对日期和时间。	 * @return {Date} 该页过期时的日期和时间。	 */	get expiresAbsolute(){		return HttpUtility.getDateFromHeader(this.getHeader("Expires"));	},		/**	 * 获取或设置从缓存中移除缓存信息的绝对日期和时间。	 * @return {Date} 该页过期时的日期和时间。	 */	set expiresAbsolute(value){		this.setHeader("Expires", value.toUTCString());	},		// Filter		// /**	 // * 获取或设置一个值，该对象表示当前标头输出流的编码。	 // * @return {Encoding} 一个编码，包含与当前标头的字符集有关的信息。	 // */	// get headerEncoding(){		// return this._wr.responseHeaderEncoding;	// },		// /**	 // * 获取或设置一个值，该对象表示当前标头输出流的编码。	 // * @return {Encoding} 一个编码，包含与当前标头的字符集有关的信息。	 // */	// set headerEncoding(value){		// this._wr.responseHeaderEncoding = value;	// },		/**	 * 获取响应标头的集合。	 * @return {Object} 响应标头的集合。	 */	get headers(){		return this._headers || (this._headers = {});	},		/**	 * 获取一个值，通过该值指示客户端是否仍连接在服务器上。	 * @return {Boolean} 如果客户端仍连接在服务器上则返回 true 。	 */	get isClientConnected(){		return this._wr.isClientConnected();	},		/**	 * 获取一个布尔值，该值指示客户端是否正在被传输到新的位置。	 * @return {Boolean} 如果客户端正在被传输到新的位置则返回 true 。	 */	get isRequestBeingRedirected(){		return !!this.getHeader("Location");	},		// Output		/**	 * 启用到输出 HTTP 内容主体的二进制输出。	 * @return {Stream} 内容正文。	 */	get outputStream(){		return this._wr.outputStream;	},		/**	 * 获取或设置 Http Location 标头的值。	 * @return {String} 通过 HTTP Location 标头传输到客户端的绝对 URI。	 */	get redirectLocation(){		return this.getHeader("Location");	},		/**	 * 获取或设置 Http Location 标头的值。	 * @return {String} 通过 HTTP Location 标头传输到客户端的绝对 URI。	 */	set redirectLocation(value){		this.setHeader("Location", value);	},		/**	 * 设置返回到客户端的 Status 栏。	 * @return {String} 设置状态代码会使描述 HTTP 输出状态的字符串返回到客户端。默认值为 200 (OK)。	 */	get status(){		return this.statusCode + " " + this.statusDescription;	},		/**	 * 设置返回到客户端的 Status 栏。	 * @return {String} 设置状态代码会使描述 HTTP 输出状态的字符串返回到客户端。默认值为 200 (OK)。	 */	set status(value){		var n = value.indexOf(' ');		this.statusCode = value.substr(0, n);		this.statusDescription = value.substr(n + 1);	},		/**	 * 获取或设置返回给客户端的输出的 HTTP 状态代码。	 * @return {Integer} 表示返回到客户端的 HTTP 输出状态的整数。默认值为 200 (OK)。有关有效状态代码的列表，请参见 Http Status Codes（Http 状态代码）。	 */	get statusCode(){		return this._statusCode;	},		/**	 * 获取或设置返回给客户端的输出的 HTTP 状态代码。	 * @return {Integer} 表示返回到客户端的 HTTP 输出状态的整数。默认值为 200 (OK)。有关有效状态代码的列表，请参见 Http Status Codes（Http 状态代码）。	 */	set statusCode(value){		if(this._wr.headersSent()) {			this._raiseHeaderWrittenException();		}		this._statusCode = value;	},		/**	 * 获取或设置返回给客户端的输出的 HTTP 状态字符串。	 * @return {String} 一个字符串，描述返回给客户端的 HTTP 输出的状态。默认值为"OK"。	 */	get statusDescription(){		return this._statusDescription || HttpWorkerRequset.getStatusDescription(this._statusCode);	},		/**	 * 获取或设置返回给客户端的输出的 HTTP 状态代码。	 * @return {String} 表示返回到客户端的 HTTP 输出状态的整数。默认值为 200 (OK)。有关有效状态代码的列表，请参见 Http Status Codes（Http 状态代码）。	 */	set statusDescription(value){		if(this._wr.headersSent()) {			this._raiseHeaderWrittenException();		}		this._statusDescription = value;	},		// Status		// SubStatusCode		// SuppressContent		/**	 * 获取或设置向客户端输出的 Last-Modified 字段。	 * @return {Date} Last-Modified 字段。	 */	get LastModified(){		return HttpUtility.getDateFromHeader(this.getHeader("Last-Modified"));	},		/**	 * 获取或设置向客户端输出的 Last-Modified 字段。	 * @return {Date} Last-Modified 字段。	 */	set LastModified(value){		this.setHeader("Last-Modified", value.toUTCString());	},        /**	 * 返回一个值，该值指示是否已为当前的请求将 HTTP 响应标头发送到客户端。	 * @return {Boolean} 如果 HTTP 响应标头已发送到客户端，则为 true；否则，为 false。	 */	get headersSent() {	    return this._wr.headersSent();	},		/**	 * 将一个 HTTP 标头添加到输出流。	 * @param {String} name 要添加 *value* 的 HTTP 头名称。	 * @param {String} value 要添加到头中的字符串。	 * @return {String} 头部内容。	 */	getHeader: function(name){		if (arguments.length < 1) {			throw new Error('`name` is required for getHeader().');		}		if (!this._headers) return;		return this._headers[name.toLowerCase()];	},		/**	 * 将一个 HTTP 标头添加到输出流。	 * @param {String} name 要添加 *value* 的 HTTP 头名称。	 * @param {String} value 要添加到头中的字符串。	 */	setHeader: function(name, value){		if (arguments.length < 2) {			throw new Error('`name` and `value` are required for setHeader().');		}		if (this._wr.headersSent()) {
		    this._raiseHeaderWrittenException();
		}				this.headers[name.toLowerCase()] = value;	},		/**	 * 将一个 HTTP 标头添加到输出流。	 * @param {String} name 要添加 *value* 的 HTTP 头名称。	 * @param {String} value 要添加到头中的字符串。	 * @return {Boolean} 如果删除成功，返回 true， 否则返回 false。	 */	removeHeader: function(name){		if (arguments.length < 1) {		    throw new Error('`name` is required for removeHeader().');		}		if (this._wr.headersSent()) {
		    this._raiseHeaderWrittenException();
		}				return delete this.headers[name.toLowerCase()];	},		// AppendCookie	// AppendHeader	// AppendToLog	// ApplyAppPathModifier		/**	 * 将一个二进制字符串写入 HTTP 输出流。	 * @param {Buffer} buffer 要写入输出流的字节。	 * @param {Number} offset=0 *buffer* 中的从零开始的字节偏移量，从此处开始将字节复制到当前流。	 * @param {Number} count=buffer.length 要写入当前流的字节数。	 */	binaryWrite: function(buffer, offset, count){		if(offset !== undefined && count !== undefined){			buffer = buffer.slice(offset, offset + count);		}				this._writeRaw(buffer);	},		/**	 * 清除缓冲区流中的所有内容输出。	 */	clear: function(){		this._buffers.length = 0;	},		/**	 * 清除缓冲区流中的所有头。	 */	clearHeaders: function() {		if(this._wr.headersSent()) {			this._raiseHeaderWrittenException();        }				if(this._headers) {			for(var item in this._headers){				delete this._headers[item];			}		}		        this._statusCode = 200;        this._statusDescription = null;        this.removeHeader("content-type");	},		/**	 * 关闭到客户端的套接字连接。	 */	close: function(){		this._wr.closeConnection();	},		/**	 * 关闭到客户端的套接字连接。	 */	end: function(data){		if(data){			this.write(data);		}		this.context.applicationInstance.onEndRequest(this.context);		this.flush(true);		this._wr.endOfRequest();		//this.close();	},		/**	 * 向客户端发送当前所有缓冲的输出。	 * @param {Boolean} finalFlush 如果这将是最后一次刷新响应数据，则为 true；否则为 false。	 */	flush: function(finalFlush){			var buffers = this._buffers,			wr = this._wr,			contentEncoding = this.contentEncoding;		if (!wr.headersSent()) {			this._writeHeaders(finalFlush);		}				for(var i = 0, len = buffers.length; i < len; i++){			wr.sendContent(buffers[i], contentEncoding);		}				buffers.length = 0;		        wr.flushResponse(finalFlush);			},		/**	 * 将一个 HTTP PICS-Label 标头追加到输出流。	 * @param {String} value 要添加到 PICS-Label 标头的字符串。	 */	pics: function(value){		this.setHeader("PICS-Label", value);	},		/**	 * 将客户端重定向到新的 URL。指定新的 URL 并指定当前页的执行是否应终止。	 * @param {String} url 目标的位置。	 * @param {Boolean} endResponse 指示当前页的执行是否应终止。	 */	redirect: function(url, endResponse){		this.statusCode = 302;		this.redirectLocation = url;		if(endResponse) {			this.write('Object Moved To <a herf="' + url + '">' + url + '</a>');			this.end();		}	},		/**	 * 更新 Cookie 集合中的一个现有 Cookie。	 * @param {HttpCookie} cookie 集合中要更新的 Cookie。	 */	setCookie: function(cookie){		if(!(cookie instanceof HttpCookie)){			cookie = new HttpCookie(cookie);		}		this.cookies.add(cookie);	},		/**	 * 将指定的文件直接写入 HTTP 响应输出流，而不在内存中缓冲该文件。	 * @param {String} filename 要写入 HTTP 输出的文件名。	 * @param {Number} offset=0 文件中的位置，将从该位置开始将内容写入到 HTTP 输出中。	 * @param {Number} length=buffer.length 要传输的字节数。	 */	transmitFile: function(filename, offset, length){			filename = this._wr.mapPath(filename);				if(!FS.existsSync(filename)){			throw new Error('file not found: ' + filename);		}				this._wr.sendResponseFromFile(filename, offset, size);	},		/**	 * 将一个字符串写入 HTTP 响应输出流。	 * @param {String} value 要写入 HTTP 输出流的字符串。	 */	write: function(value){		this._writeRaw(new Buffer(String(value)));	},		/**	 * 将一个字符串进行 HTML 编码后写入 HTTP 响应输出流。	 * @param {String} value 要写入 HTTP 输出流的字符串。	 */	writeText: function(value){		this.write(HttpUtility.htmlEncode(value));	},		/**	 * 将指定文件的内容作为文件块直接写入 HTTP 响应输出流。	 * @param {String} filename 要写入 HTTP 输出的文件名。	 * @param {Number} offset=0 文件中将开始进行写入的字节位置。	 * @param {Number} size=buffer.length 要写入输出流的字节数。	 */	writeFile: function(filename, offset, size){			/* var me = this;				filename = this._wr.mapPath(filename);				if(!FS.existsSync(filename)){			throw new Error('file not found: ' + filename);		}			FS.readFile(filename, function(error, content) {			me.binaryWrite(content, offset, size);		});		 */			this.binaryWrite(FS.readFileSync(this._wr.mapPath(filename)), offset, size);	},		/**	 * 添加尾部头。	 * @param {Object} headers 头部信息。	 */	addTrailers: function(headers){		this._wr.addTrailers(headers);	},		writeHead: function(statusCode){		var reasonPhrase, headers, headerIndex;		if (typeof arguments[1] == 'string') {			reasonPhrase = arguments[1];			headerIndex = 2;		} else {			reasonPhrase = HttpWorkerRequset.getStatusDescription(statusCode);			headerIndex = 1;		}				this.statusCode = statusCode;		this.statusDescription = reasonPhrase;				var obj = arguments[headerIndex];		if (obj) {			for(var key in obj){				this.setHeader(key, obj[key]);			}		}	}	};var dateCache;function utcDate() {  if (!dateCache) {    var d = new Date();    dateCache = d.toUTCString();    setTimeout(function() {      dateCache = undefined;    }, 1000 - d.getMilliseconds());  }  return dateCache;}module.exports = HttpResponse;