var Path = require('path'),	Url = require('url'),	HttpWorkerRequset = require('./httpworkerrequest');/** * 基于默认坏境支持实现的 HttpWorkerRequset 类。 * @class * @extends HttpWorkerRequset */function DefaultHttpWorkerRequest(request, response, application){		var me = this;	me._req = request;	me._res = response;	me.applicationInstance = application;		// 初始化 request	request.addListener("data", function(data) {		if(!me._entityBodys) {			me._entityBodys = [];			me._entityBodys.count = 0;		}				me._entityBodys.push(data);		me._entityBodys.count += data.length;		if (me._entityBodys.count.length > 1e6) {			// FLOOD ATTACK OR FAULTY CLIENT, NUKE REQUEST			me.closeConnection();		}	});		var path = me._path = Url.parse(request.url, false);		try{		path.pathname = decodeURIComponent(path.pathname);	}catch(e){		}	// 根据路径搜索匹配的虚拟路径。	for(var virtualPath in application.virtualPaths) {		if((path.pathname + "/").indexOf(virtualPath + "/") == 0) {			me.appPath = virtualPath;			me.appPhysicalPath = application.virtualPaths[virtualPath];			return;		}	}	me.appPath = "";	me.appPhysicalPath = application.physicalPath;}DefaultHttpWorkerRequest.prototype = {	__proto__: HttpWorkerRequset.prototype,	_req: null,		_res: null,		_path: null,		_entityBodys: null,		applicationInstance: null,		/**	 * 获取传入的 HTTP 实体主体的内容。	 * @returns {Stream} 请求正文。	 */	get inputStream(){		return this._res;	},		/**	 * 启用到输出 HTTP 内容主体的二进制输出。	 * @returns {Stream} 内容正文。	 */	get outputStream(){		return this._res;	},		/**	 * 获取或设置一个编码，该对象表示当前标头输出流的编码。	 */ 	get headerEncoding(){		return this.applicationInstance.headerEncoding;	},		/**	 * 获取或设置一个编码，该对象表示当前标头输出流的编码。	 */ 	set contentEncoding(value){		this._req.setEncoding(value);	},		/**	 * 获取或设置一个编码，该对象表示当前标头输出流的编码。	 */ 	get contentEncoding(){		return this.applicationInstance.contentEncoding;	},		/**	 * 获取 Machine.config 文件的完整物理路径。	 */	get machineConfigPath(){			},		// /**	 // * 获取网站服务器文件的安装目录的物理路径。	 // * @returns 网站服务器文件的安装目录的物理路径。	 // */	// get machineInstallDirectory(){			// },		// /**	 // * 获取根 Web.config 文件的完整物理路径。	 // * @returns 根 Web.config 文件的物理路径。	 // */	// get rootWebConfigPath(){			// },		/**	 * 终止与客户端的连接。	 */	closeConnection: function(){		this._req.connection.destroy();	},		/**	 * 返回当前正在执行的服务器应用程序的虚拟路径。	 * @returns {String} 当前应用程序的虚拟路径。	 */	getAppPath: function(){		return this.appPath;	},		/**	 * 返回当前正在执行的服务器应用程序的物理路径。	 * @returns {String} 当前应用程序的物理路径。	 */	getAppPathTranslated: function(){		return this.appPhysicalPath;	},		/**	 * 在派生类中被重写时，返回当前 URL 的应用程序池 ID。	 * @returns {String} 返回应用程序池 ID。	 */	getAppPoolID: function(){		return this.applicationInstance.id;	},		/**	 * 获取从客户端读入的字节数。	 * @returns {Number} 客户端读入的字节数。	 */	getBytesRead: function(){		return this._req.connection.bytesRead;	},		/**	 * 在派生类中被重写时，从客户端发出的请求获取证书字段（以 X.509 标准指定）。	 * @returns {Buffer} 包含整个证书内容流的字节数组。	 */	getClientCertificate: function(){		return null;	},		/**	 * 获取证书颁发者（以二进制格式表示）。	 * @returns {Buffer} 包含以二进制格式表示的证书颁发者的字节数组。	 */	getClientCertificateBinaryIssuer: function(){		return null;	},		/**	 * 在派生类中被重写时，返回用于编码客户端证书的编码。	 * @returns {Number} 表示为整数的证书编码。	 */	getClientCertificateEncoding: function(){		return null;	},		/**	 * 在派生类中被重写时，获取与客户端证书关联的 PublicKey 对象。	 * @returns {Buffer} 包含整个证书内容流的字节数组。	 */	getClientCertificatePublicKey: function(){		return null;	},		/**	 * 在派生类中被重写时，则获取证书开始生效的日期。此日期随区域设置的不同而不同。	 * @returns {Date} 表示证书生效时间的 Date 对象。	 */	getClientCertificateValidFrom: function(){		return null;	},		/**	 * 获取证书到期日期。	 * @returns {Date} 表示证书失效日期的 Date 对象。	 */	getClientCertificateValidUntil: function(){		return null;	},		/**	 * 在派生类中被重写时，返回当前连接的 ID。	 * @returns {Number} 始终返回 0。	 */	getConnectionID: function(){		return 0;	},		/**	 * 在派生类中被重写时，返回所请求的 URI 的虚拟路径。	 * @returns {String} 请求的 URI 的路径。	 */	getFilePath: function(){		return this._path.pathname;	},		/**	 * 返回请求的 URI 的物理文件路径（并将其从虚拟路径转换成物理路径：例如，从"/proj1/page.aspx"转换成"c:\dir\page.aspx"）。	 * @returns {String} 请求的 URI 的已转换的物理文件路径。	 */	getFilePathTranslated: function(){		return this.mapPath(this._path.pathname);	},		/**	 * 返回请求标头的指定成员。	 * @returns {String} 请求标头中返回的 HTTP 谓词。	 */	getHttpVerbName: function(){		return this._req.method;	},		/**	 * 提供对请求的 HTTP 版本（如"HTTP/1.1"）的访问。	 * @returns {String} 请求标头中返回的 HTTP 版本。	 */	getHttpVersion: function(){		return 'HTTP/' + this._req.httpVersion;	},		/**	 * 返回指定字段的 HTTP 请求标头。	 * @param {String} name 标头的名称。	 * @returns {String} HTTP 请求标头。	 */	getRequestHeader: function(name){		return this._req.headers[name.toLowerCase()];	},		/**	 * 返回 HTTP 请求标头。	 * @returns {Object} 获取请求头对象。	 */	getAllRequestHeaders: function(){		return this._req.headers || {};	},		/**	 * 请求标头中返回的服务器 IP 地址。	 * @returns {String} 请求标头中返回的服务器 IP 地址。	 */	getLocalAddress: function(){		var addr = this._req.connection.server.address();		return addr ? addr.address : null;	},		/**	 * 请求标头中返回的服务器端口号。	 * @returns {String} 请求标头中返回的服务器端口号。	 */	getLocalPort: function(){		var addr = this._req.connection.server.address();		return addr ? addr.port : 0;	},		/**	 * 在派生类中被重写时，返回 HTTP 协议（HTTP 或 HTTPS）。	 * @returns {String} 如果使用了 SSL ，是HTTPS；否则，为 HTTP。	 */	getProtocol: function(){		return this.isSecure() ? "http" : "https";	},		/**	 * 返回请求 URL 中指定的查询字符串。	 * @returns {String} 请求查询字符串。	 */	getQueryString: function(){		return this._path.query || "";	},		/**	 * 返回附加了查询字符串的请求标头中包含的 URL 路径。	 * @returns {String} 请求标头的原始 URL 路径。	 */	getRawUrl: function(){		return this._path.href;	},		/**	 * 获取请求的开始时间。	 * @returns {Date} 一个开始时间。	 */	getRequestTimestamp: function(){		return this._req.connection._idleStart;	},		/**	 * 提供对请求标头的指定成员的访问。	 * @returns {String} 客户端的 IP 地址。	 */	getRemoteAddress: function(){		return this._req.connection.remoteAddress;	},		/**	 * 在派生类中被重写时，返回客户端计算机的名称。	 * @returns {String} 客户端计算机的名称。	 */	getRemoteName: function(){		return this.getRemoteAddress();	},		/**	 * 提供对请求标头的指定成员的访问。	 * @returns {Number} 客户端的 HTTP 端口号。	 */	getRemotePort: function(){		return this._req.connection.remotePort;	},		/**	 * 在派生类中被重写时，返回请求的原因。	 * @returns {Number} 原因代码。	 */	getRequestReason: function(){		var header = this.getRequestHeader('X-Requested-With');		return header && /XMLHttpRequest/i.test(header) ? 1 : 0;	},		/**	 * 在派生类中被重写时，返回本地服务器的名称。	 * @returns {Number} 本地服务器的名称。	 */	getServerName: function(){		return "XFly/3.0";	},		/**	 * 从与请求关联的服务器变量词典返回单个服务器变量。	 * @param {String} name 请求的服务器变量的名称。	 * @returns {Number} 请求的服务器变量。	 */	getServerVariable: function(name){		return null;	},		/**	 * 返回请求的 URI 的虚拟路径。	 * @returns {String} 请求的 URI 的路径。	 */	getUriPath: function(){		return this._path.path;	},		/**	 * 返回一个值，该值指示客户端连接是否仍处于活动状态。	 * @returns {Boolean} 如果客户端连接仍处于活动状态，则为 true；否则，为 false。	 */	isClientConnected: function(){		return this._req.connection.destroyed;	},		/**	 * 返回一个指示连接是否使用 SSL 的值。	 * @returns {Boolean} 如果连接是 SSL 连接，则为 true；否则为 false。默认值为 false。	 */	isSecure: function(){		return false;	},		hasEntityBody: function(){		return this._entityBodys ? this._entityBodys.count > 0 : false;	},		getTotalEntityBodyLength: function(){		return this._entityBodys ? this._entityBodys.count : 0;	},		getEntityBody: function(){		return this._entityBodys && this._entityBodys.count > 0 ? Buffer.concat(this._entityBodys) : null;	},		/**	 * 返回与指定虚拟路径相对应的物理路径。	 * @param {String} virtualPath 虚拟路径。	 * @returns {String} 参数中指定的虚拟路径相对应的物理路径。	 */	mapPath: function(virtualPath){		return Path.normalize(this.appPhysicalPath + virtualPath.substr(this.appPath.length));	},		/**	 * 返回一个值，该值指示是否已为当前的请求将 HTTP 响应标头发送到客户端。	 * @returns {Boolean} 如果 HTTP 响应标头已发送到客户端，则为 true；否则，为 false。	 */	headersSent: function(){		return !!this._res._headerSent;	},		/**	 * 指定响应的 HTTP 状态代码和状态说明，例如 SendStatus(200, "Ok")。	 * @param {Number} statusCode 要发送的状态代码。	 * @param {String} statusDescription 要发送的状态说明。	 */	sendStatus: function(statusCode, statusDescription){		this._res._header = this.getHttpVersion() + ' ' + statusCode + ' ' + statusDescription + '\r\n';							if (statusCode === 204 || statusCode === 304 ||			  (100 <= statusCode && statusCode <= 199)) {			// RFC 2616, 10.2.5:			// The 204 response MUST NOT include a message-body, and thus is always			// terminated by the first empty line after the header fields.			// RFC 2616, 10.3.5:			// The 304 response MUST NOT contain a message-body, and thus is always			// terminated by the first empty line after the header fields.			// RFC 2616, 10.1 Informational 1xx:			// This class of status code indicates a provisional response,			// consisting only of the Status-Line and optional headers, and is			// terminated by an empty line.			this._res._hasBody = false;		}		// don't keep alive connections where the client expects 100 Continue		// but we sent a final status; they may put extra bytes on the wire.		if (this._res._expect_continue && ! this._res._sent100) {			this._res.shouldKeepAlive = false;		}	},		sendHeader: function(name, value){		this._res._header += name + ': '+ value + '\r\n';	},		/**	 * 将 Content-Length HTTP 标头添加到小于或等于 2 GB 的消息正文的响应。	 * @param {Number} contentLength 响应的长度（以字节为单位）。	 */	sendCalculatedContentLength: function(contentLength){		this._res._header += "Content-Length: " + contentLength + '\r\n';	},		/**	 * 将指定的 *HttpCookieCollection* 输出到 HTTP 响应。	 * @param {HttpCookieCollection} cookies 要发送的状态代码。	 */	sendCookies: function(cookies){		for(var key in cookies){			if(cookies.hasOwnProperty(key)){				var cookie = cookies[key];				if(typeof cookie === 'string'){					cookie = key + '=' + cookie;										try{						cookie = encodeURI(cookie);					}catch(e){										}									this._res._header += "Set-Cookie: " + cookie + '\r\n';				} else {					this._res._header += "Set-Cookie: " + cookie.toFullString() + '\r\n';				}			}		}	},		setKeepAlive: function(value, chunk){		if(value) {			this._res.shouldKeepAlive = true;		} else {			this._res._last = true;		}				this.chunkedEncoding = chunk;	},		/**	 * 由运行库使用以通知 *HttpWorkerRequest* 当前请求的请求头已发送完毕。	 */	endOfHeaderSent: function(){				for(var key in this.applicationInstance.headers){			this.sendHeader(key, this.applicationInstance.headers[key]);		}				this._res._headerSent = true;		this.sendResponseFromMemory(this._res._header + '\r\n', this.headerEncoding);	},		/**	 * 将正文字节添加到响应。同时添加 chunk 标记。	 * @param {String} data 要发送的字节数组。	 * @param {Number} encoding 要发送的编码。	 */	sendContent: function(data, encoding){				if (!this._res._hasBody) {			console.trace('This type of response MUST NOT have a body. ' +		  'Ignoring write() calls.');			return true;		}		if (data.length === 0) return false;		if (typeof data !== 'string' && !Buffer.isBuffer(data)) {			throw new TypeError('first argument must be a string or Buffer');		}				if (this.chunkedEncoding) {			if (typeof data === 'string') {			  return this.sendResponseFromMemory(Buffer.byteLength(data, encoding).toString(16) + '\r\n' + data + '\r\n', encoding);			} else {			  // buffer			  this.sendResponseFromMemory(data.length.toString(16) + '\r\n');			  this.sendResponseFromMemory(data);			  return this.sendResponseFromMemory('\r\n');			}		} else {			return this.sendResponseFromMemory(data, encoding);		}	},		/**	 * 将 Content-Length HTTP 标头添加到小于或等于 2 GB 的消息正文的响应。	 * @param {String} filename 要写入 HTTP 输出的文件名。	 * @param {Number} offset=0 文件中的位置，将从该位置开始将内容写入到 HTTP 输出中。	 * @param {Number} length=buffer.length 要传输的字节数。	 */	sendResponseFromFile: function(filename, offset, length){				var options = {			flags : "r", 			encoding : null		};				if(offset !== undefined) {			options.start = options;					if(length !== undefined) {				options.end = offset + length;			}		}				FS.createReadStream(filename, options).pipe(this._res);	},		/**	 * 将字节添加到响应。	 * @param {String} data 要发送的字节数组。	 * @param {Number} encoding 要发送的编码。	 */	sendResponseFromMemory: function(data, encoding){		this._res._writeRaw(data, encoding);		//this._res.write(data, encoding);	},		/**	 * 将所有挂起的响应数据发送到客户端。	 * @param {Boolean} finalFlush 如果这将是最后一次刷新响应数据，则为 true；否则为 false。	 */	flushResponse: function(finalFlush){	    if(finalFlush){	        if(this.chunkedEncoding){	            this.sendResponseFromMemory('0\r\n\r\n');	        }			this._res.end();		} else {	        this._res._flush();		}	},		/**	 *  由运行库使用以通知 *HttpWorkerRequest* 当前请求的请求处理已完成。	 */	endOfRequest: function(){			},		///**	// * 将头部添加到相应底部。	// * @param {String} headers 要发送的头部。	// */	//addTrailers: function(headers){	//	this._res.addTrailers(headers);	//},		/**	 * 在发送所有响应数据后注册可选通知。	 * @param {Function} callback 在发送所有数据（带外）后调用的通知回调。	 * @param {Object} extraData 回调的附加参数。	 */	setEndOfSendNotification: function(callback, extraData){		if(extraData){			callback = callback.bind(this, extraData);		}		this._res.on('close', callback);	},		getPathInfo: function(){		return '';	},		rewritePath: function(path){		var tp = this._path;		path = Url.parse(path, false);		try{			tp.pathname = decodeURIComponent(path.pathname);		}catch(e){			tp.pathname = path.pathname;		}				tp.path = tp.pathname;				if('hash' in path){			tp.hash = path;		}				if('search' in path){			tp.search = path.search;			tp.query = path.query;						tp.path += tp.search;		}			}	};module.exports = DefaultHttpWorkerRequest;