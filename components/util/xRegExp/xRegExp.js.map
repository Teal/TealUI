{"version":3,"file":"xRegExp.js","sources":["xRegExp.js"],"sourcesContent":["/*!\r\n * XRegExp v2.0.0\r\n * (c) 2007-2012 Steven Levithan <http://xregexp.com/>\r\n * MIT License\r\n */\r\n\r\n/**\r\n * XRegExp provides augmented, extensible JavaScript regular expressions. You get new syntax,\r\n * flags, and methods beyond what browsers support natively. XRegExp is also a regex utility belt\r\n * with tools to make your client-side grepping simpler and more powerful, while freeing you from\r\n * worrying about pesky cross-browser inconsistencies and the dubious `lastIndex` property. See\r\n * XRegExp's documentation (http://xregexp.com/) for more details.\r\n * @module xregexp\r\n * @requires N/A\r\n */\r\nvar XRegExp;\r\n\r\n// Avoid running twice; that would reset tokens and could break references to native globals\r\nXRegExp = XRegExp || (function (undef) {\r\n    \"use strict\";\r\n\r\n    /*--------------------------------------\r\n     *  Private variables\r\n     *------------------------------------*/\r\n\r\n    var self,\r\n        addToken,\r\n        add,\r\n\r\n// Optional features; can be installed and uninstalled\r\n        features = {\r\n            natives: false,\r\n            extensibility: false\r\n        },\r\n\r\n// Store native methods to use and restore (\"native\" is an ES3 reserved keyword)\r\n        nativ = {\r\n            exec: RegExp.prototype.exec,\r\n            test: RegExp.prototype.test,\r\n            match: String.prototype.match,\r\n            replace: String.prototype.replace,\r\n            split: String.prototype.split\r\n        },\r\n\r\n// Storage for fixed/extended native methods\r\n        fixed = {},\r\n\r\n// Storage for cached regexes\r\n        cache = {},\r\n\r\n// Storage for addon tokens\r\n        tokens = [],\r\n\r\n// Token scopes\r\n        defaultScope = \"default\",\r\n        classScope = \"class\",\r\n\r\n// Regexes that match native regex syntax\r\n        nativeTokens = {\r\n            // Any native multicharacter token in default scope (includes octals, excludes character classes)\r\n            \"default\": /^(?:\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\d*|x[\\dA-Fa-f]{2}|u[\\dA-Fa-f]{4}|c[A-Za-z]|[\\s\\S])|\\(\\?[:=!]|[?*+]\\?|{\\d+(?:,\\d*)?}\\??)/,\r\n            // Any native multicharacter token in character class scope (includes octals)\r\n            \"class\": /^(?:\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\dA-Fa-f]{2}|u[\\dA-Fa-f]{4}|c[A-Za-z]|[\\s\\S]))/\r\n        },\r\n\r\n// Any backreference in replacement strings\r\n        replacementToken = /\\$(?:{([\\w$]+)}|(\\d\\d?|[\\s\\S]))/g,\r\n\r\n// Any character with a later instance in the string\r\n        duplicateFlags = /([\\s\\S])(?=[\\s\\S]*\\1)/g,\r\n\r\n// Any greedy/lazy quantifier\r\n        quantifier = /^(?:[?*+]|{\\d+(?:,\\d*)?})\\??/,\r\n\r\n// Check for correct `exec` handling of nonparticipating capturing groups\r\n        compliantExecNpcg = nativ.exec.call(/()??/, \"\")[1] === undef,\r\n\r\n// Check for flag y support (Firefox 3+)\r\n        hasNativeY = RegExp.prototype.sticky !== undef,\r\n\r\n// Used to kill infinite recursion during XRegExp construction\r\n        isInsideConstructor = false,\r\n\r\n// Storage for known flags, including addon flags\r\n        registeredFlags = \"gim\" + (hasNativeY ? \"y\" : \"\");\r\n\r\n    /*--------------------------------------\r\n     *  Private helper functions\r\n     *------------------------------------*/\r\n\r\n    /**\r\n     * Attaches XRegExp.prototype properties and named capture supporting data to a regex object.\r\n     * @private\r\n     * @param {RegExp} regex Regex to augment.\r\n     * @param {Array} captureNames Array with capture names, or null.\r\n     * @param {Boolean} [isNative] Whether the regex was created by `RegExp` rather than `XRegExp`.\r\n     * @return {RegExp} Augmented regex.\r\n     */\r\n    function augment(regex, captureNames, isNative) {\r\n        var p;\r\n        // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value\r\n        for (p in self.prototype) {\r\n            if (self.prototype.hasOwnProperty(p)) {\r\n                regex[p] = self.prototype[p];\r\n            }\r\n        }\r\n        regex.xregexp = { captureNames: captureNames, isNative: !!isNative };\r\n        return regex;\r\n    }\r\n\r\n    /**\r\n     * Returns native `RegExp` flags used by a regex object.\r\n     * @private\r\n     * @param {RegExp} regex Regex to check.\r\n     * @return {String} Native flags in use.\r\n     */\r\n    function getNativeFlags(regex) {\r\n        //return nativ.exec.call(/\\/([a-z]*)$/i, String(regex))[1];\r\n        return (regex.global ? \"g\" : \"\") +\r\n               (regex.ignoreCase ? \"i\" : \"\") +\r\n               (regex.multiline ? \"m\" : \"\") +\r\n               (regex.extended ? \"x\" : \"\") + // Proposed for ES6, included in AS3\r\n               (regex.sticky ? \"y\" : \"\"); // Proposed for ES6, included in Firefox 3+\r\n    }\r\n\r\n    /**\r\n     * Copies a regex object while preserving special properties for named capture and augmenting with\r\n     * `XRegExp.prototype` methods. The copy has a fresh `lastIndex` property (set to zero). Allows\r\n     * adding and removing flags while copying the regex.\r\n     * @private\r\n     * @param {RegExp} regex Regex to copy.\r\n     * @param {String} [addFlags] Flags to be added while copying the regex.\r\n     * @param {String} [removeFlags] Flags to be removed while copying the regex.\r\n     * @return {RegExp} Copy of the provided regex, possibly with modified flags.\r\n     */\r\n    function copy(regex, addFlags, removeFlags) {\r\n        if (!self.isRegExp(regex)) {\r\n            throw new TypeError(\"type RegExp expected\");\r\n        }\r\n        var flags = nativ.replace.call(getNativeFlags(regex) + (addFlags || \"\"), duplicateFlags, \"\");\r\n        if (removeFlags) {\r\n            // Would need to escape `removeFlags` if this was public\r\n            flags = nativ.replace.call(flags, new RegExp(\"[\" + removeFlags + \"]+\", \"g\"), \"\");\r\n        }\r\n        if (regex.xregexp && !regex.xregexp.isNative) {\r\n            // Compiling the current (rather than precompilation) source preserves the effects of nonnative source flags\r\n            regex = augment(self(regex.source, flags),\r\n                            regex.xregexp.captureNames ? regex.xregexp.captureNames.slice(0) : null);\r\n        } else {\r\n            // Augment with `XRegExp.prototype` methods, but use native `RegExp` (avoid searching for special tokens)\r\n            regex = augment(new RegExp(regex.source, flags), null, true);\r\n        }\r\n        return regex;\r\n    }\r\n\r\n    /*\r\n     * Returns the last index at which a given value can be found in an array, or `-1` if it's not\r\n     * present. The array is searched backwards.\r\n     * @private\r\n     * @param {Array} array Array to search.\r\n     * @param {*} value Value to locate in the array.\r\n     * @return {Number} Last zero-based index at which the item is found, or -1.\r\n     */\r\n    function lastIndexOf(array, value) {\r\n        var i = array.length;\r\n        if (Array.prototype.lastIndexOf) {\r\n            return array.lastIndexOf(value); // Use the native method if available\r\n        }\r\n        while (i--) {\r\n            if (array[i] === value) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Determines whether an object is of the specified type.\r\n     * @private\r\n     * @param {*} value Object to check.\r\n     * @param {String} type Type to check for, in lowercase.\r\n     * @return {Boolean} Whether the object matches the type.\r\n     */\r\n    function isType(value, type) {\r\n        return Object.prototype.toString.call(value).toLowerCase() === \"[object \" + type + \"]\";\r\n    }\r\n\r\n    /**\r\n     * Prepares an options object from the given value.\r\n     * @private\r\n     * @param {String|Object} value Value to convert to an options object.\r\n     * @return {Object} Options object.\r\n     */\r\n    function prepareOptions(value) {\r\n        value = value || {};\r\n        if (value === \"all\" || value.all) {\r\n            value = { natives: true, extensibility: true };\r\n        } else if (isType(value, \"string\")) {\r\n            value = self.forEach(value, /[^\\s,]+/, function (m) {\r\n                this[m] = true;\r\n            }, {});\r\n        }\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Runs built-in/custom tokens in reverse insertion order, until a match is found.\r\n     * @private\r\n     * @param {String} pattern Original pattern from which an XRegExp object is being built.\r\n     * @param {Number} pos Position to search for tokens within `pattern`.\r\n     * @param {Number} scope Current regex scope.\r\n     * @param {Object} context Context object assigned to token handler functions.\r\n     * @return {Object} Object with properties `output` (the substitution string returned by the\r\n     *   successful token handler) and `match` (the token's match array), or null.\r\n     */\r\n    function runTokens(pattern, pos, scope, context) {\r\n        var i = tokens.length,\r\n            r = null,\r\n            match,\r\n            t;\r\n        // Protect against constructing XRegExps within token handler and trigger functions\r\n        isInsideConstructor = true;\r\n        // Must reset `isInsideConstructor`, even if a `trigger` or `handler` throws\r\n        try {\r\n            while (i--) { // Run in reverse order\r\n                t = tokens[i];\r\n                if ((t.scope === \"all\" || t.scope === scope) && (!t.trigger || t.trigger.call(context))) {\r\n                    t.pattern.lastIndex = pos;\r\n                    match = fixed.exec.call(t.pattern, pattern); // Fixed `exec` here allows use of named backreferences, etc.\r\n                    if (match && match.index === pos) {\r\n                        r = {\r\n                            output: t.handler.call(context, match, scope),\r\n                            match: match\r\n                        };\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } catch (err) {\r\n            throw err;\r\n        } finally {\r\n            isInsideConstructor = false;\r\n        }\r\n        return r;\r\n    }\r\n\r\n    /**\r\n     * Enables or disables XRegExp syntax and flag extensibility.\r\n     * @private\r\n     * @param {Boolean} on `true` to enable; `false` to disable.\r\n     */\r\n    function setExtensibility(on) {\r\n        self.addToken = addToken[on ? \"on\" : \"off\"];\r\n        features.extensibility = on;\r\n    }\r\n\r\n    /**\r\n     * Enables or disables native method overrides.\r\n     * @private\r\n     * @param {Boolean} on `true` to enable; `false` to disable.\r\n     */\r\n    function setNatives(on) {\r\n        RegExp.prototype.exec = (on ? fixed : nativ).exec;\r\n        RegExp.prototype.test = (on ? fixed : nativ).test;\r\n        String.prototype.match = (on ? fixed : nativ).match;\r\n        String.prototype.replace = (on ? fixed : nativ).replace;\r\n        String.prototype.split = (on ? fixed : nativ).split;\r\n        features.natives = on;\r\n    }\r\n\r\n    /*--------------------------------------\r\n     *  Constructor\r\n     *------------------------------------*/\r\n\r\n    /**\r\n     * Creates an extended regular expression object for matching text with a pattern. Differs from a\r\n     * native regular expression in that additional syntax and flags are supported. The returned object\r\n     * is in fact a native `RegExp` and works with all native methods.\r\n     * @class XRegExp\r\n     * @constructor\r\n     * @param {String|RegExp} pattern Regex pattern string, or an existing `RegExp` object to copy.\r\n     * @param {String} [flags] Any combination of flags:\r\n     *   <li>`g` - global\r\n     *   <li>`i` - ignore case\r\n     *   <li>`m` - multiline anchors\r\n     *   <li>`n` - explicit capture\r\n     *   <li>`s` - dot matches all (aka singleline)\r\n     *   <li>`x` - free-spacing and line comments (aka extended)\r\n     *   <li>`y` - sticky (Firefox 3+ only)\r\n     *   Flags cannot be provided when constructing one `RegExp` from another.\r\n     * @return {RegExp} Extended regular expression object.\r\n     * @example\r\n     *\r\n     * // With named capture and flag x\r\n     * date = XRegExp('(?<year>  [0-9]{4}) -?  # year  \\n\\\r\n     *                 (?<month> [0-9]{2}) -?  # month \\n\\\r\n     *                 (?<day>   [0-9]{2})     # day   ', 'x');\r\n     *\r\n     * // Passing a regex object to copy it. The copy maintains special properties for named capture,\r\n     * // is augmented with `XRegExp.prototype` methods, and has a fresh `lastIndex` property (set to\r\n     * // zero). Native regexes are not recompiled using XRegExp syntax.\r\n     * XRegExp(/regex/);\r\n     */\r\n    self = function (pattern, flags) {\r\n        if (self.isRegExp(pattern)) {\r\n            if (flags !== undef) {\r\n                throw new TypeError(\"can't supply flags when constructing one RegExp from another\");\r\n            }\r\n            return copy(pattern);\r\n        }\r\n        // Tokens become part of the regex construction process, so protect against infinite recursion\r\n        // when an XRegExp is constructed within a token handler function\r\n        if (isInsideConstructor) {\r\n            throw new Error(\"can't call the XRegExp constructor within token definition functions\");\r\n        }\r\n\r\n        var output = [],\r\n            scope = defaultScope,\r\n            tokenContext = {\r\n                hasNamedCapture: false,\r\n                captureNames: [],\r\n                hasFlag: function (flag) {\r\n                    return flags.indexOf(flag) > -1;\r\n                }\r\n            },\r\n            pos = 0,\r\n            tokenResult,\r\n            match,\r\n            chr;\r\n        pattern = pattern === undef ? \"\" : String(pattern);\r\n        flags = flags === undef ? \"\" : String(flags);\r\n\r\n        if (nativ.match.call(flags, duplicateFlags)) { // Don't use test/exec because they would update lastIndex\r\n            throw new SyntaxError(\"invalid duplicate regular expression flag\");\r\n        }\r\n        // Strip/apply leading mode modifier with any combination of flags except g or y: (?imnsx)\r\n        pattern = nativ.replace.call(pattern, /^\\(\\?([\\w$]+)\\)/, function ($0, $1) {\r\n            if (nativ.test.call(/[gy]/, $1)) {\r\n                throw new SyntaxError(\"can't use flag g or y in mode modifier\");\r\n            }\r\n            flags = nativ.replace.call(flags + $1, duplicateFlags, \"\");\r\n            return \"\";\r\n        });\r\n        self.forEach(flags, /[\\s\\S]/, function (m) {\r\n            if (registeredFlags.indexOf(m[0]) < 0) {\r\n                throw new SyntaxError(\"invalid regular expression flag \" + m[0]);\r\n            }\r\n        });\r\n\r\n        while (pos < pattern.length) {\r\n            // Check for custom tokens at the current position\r\n            tokenResult = runTokens(pattern, pos, scope, tokenContext);\r\n            if (tokenResult) {\r\n                output.push(tokenResult.output);\r\n                pos += (tokenResult.match[0].length || 1);\r\n            } else {\r\n                // Check for native tokens (except character classes) at the current position\r\n                match = nativ.exec.call(nativeTokens[scope], pattern.slice(pos));\r\n                if (match) {\r\n                    output.push(match[0]);\r\n                    pos += match[0].length;\r\n                } else {\r\n                    chr = pattern.charAt(pos);\r\n                    if (chr === \"[\") {\r\n                        scope = classScope;\r\n                    } else if (chr === \"]\") {\r\n                        scope = defaultScope;\r\n                    }\r\n                    // Advance position by one character\r\n                    output.push(chr);\r\n                    ++pos;\r\n                }\r\n            }\r\n        }\r\n\r\n        return augment(new RegExp(output.join(\"\"), nativ.replace.call(flags, /[^gimy]+/g, \"\")),\r\n                       tokenContext.hasNamedCapture ? tokenContext.captureNames : null);\r\n    };\r\n\r\n    /*--------------------------------------\r\n     *  Public methods/properties\r\n     *------------------------------------*/\r\n\r\n    // Installed and uninstalled states for `XRegExp.addToken`\r\n    addToken = {\r\n        on: function (regex, handler, options) {\r\n            options = options || {};\r\n            if (regex) {\r\n                tokens.push({\r\n                    pattern: copy(regex, \"g\" + (hasNativeY ? \"y\" : \"\")),\r\n                    handler: handler,\r\n                    scope: options.scope || defaultScope,\r\n                    trigger: options.trigger || null\r\n                });\r\n            }\r\n            // Providing `customFlags` with null `regex` and `handler` allows adding flags that do\r\n            // nothing, but don't throw an error\r\n            if (options.customFlags) {\r\n                registeredFlags = nativ.replace.call(registeredFlags + options.customFlags, duplicateFlags, \"\");\r\n            }\r\n        },\r\n        off: function () {\r\n            throw new Error(\"extensibility must be installed before using addToken\");\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Extends or changes XRegExp syntax and allows custom flags. This is used internally and can be\r\n     * used to create XRegExp addons. `XRegExp.install('extensibility')` must be run before calling\r\n     * this function, or an error is thrown. If more than one token can match the same string, the last\r\n     * added wins.\r\n     * @memberOf XRegExp\r\n     * @param {RegExp} regex Regex object that matches the new token.\r\n     * @param {Function} handler Function that returns a new pattern string (using native regex syntax)\r\n     *   to replace the matched token within all future XRegExp regexes. Has access to persistent\r\n     *   properties of the regex being built, through `this`. Invoked with two arguments:\r\n     *   <li>The match array, with named backreference properties.\r\n     *   <li>The regex scope where the match was found.\r\n     * @param {Object} [options] Options object with optional properties:\r\n     *   <li>`scope` {String} Scopes where the token applies: 'default', 'class', or 'all'.\r\n     *   <li>`trigger` {Function} Function that returns `true` when the token should be applied; e.g.,\r\n     *     if a flag is set. If `false` is returned, the matched string can be matched by other tokens.\r\n     *     Has access to persistent properties of the regex being built, through `this` (including\r\n     *     function `this.hasFlag`).\r\n     *   <li>`customFlags` {String} Nonnative flags used by the token's handler or trigger functions.\r\n     *     Prevents XRegExp from throwing an invalid flag error when the specified flags are used.\r\n     * @example\r\n     *\r\n     * // Basic usage: Adds \\a for ALERT character\r\n     * XRegExp.addToken(\r\n     *   /\\\\a/,\r\n     *   function () {return '\\\\x07';},\r\n     *   {scope: 'all'}\r\n     * );\r\n     * XRegExp('\\\\a[\\\\a-\\\\n]+').test('\\x07\\n\\x07'); // -> true\r\n     */\r\n    self.addToken = addToken.off;\r\n\r\n    /**\r\n     * Caches and returns the r of calling `XRegExp(pattern, flags)`. On any subsequent call with\r\n     * the same pattern and flag combination, the cached copy is returned.\r\n     * @memberOf XRegExp\r\n     * @param {String} pattern Regex pattern string.\r\n     * @param {String} [flags] Any combination of XRegExp flags.\r\n     * @return {RegExp} Cached XRegExp object.\r\n     * @example\r\n     *\r\n     * while (match = XRegExp.cache('.', 'gs').exec(str)) {\r\n     *   // The regex is compiled once only\r\n     * }\r\n     */\r\n    self.cache = function (pattern, flags) {\r\n        var key = pattern + \"/\" + (flags || \"\");\r\n        return cache[key] || (cache[key] = self(pattern, flags));\r\n    };\r\n\r\n    /**\r\n     * Escapes any regular expression metacharacters, for use when matching literal strings. The r\r\n     * can safely be used at any point within a regex that uses any flags.\r\n     * @memberOf XRegExp\r\n     * @param {String} str String to escape.\r\n     * @return {String} String with regex metacharacters escaped.\r\n     * @example\r\n     *\r\n     * XRegExp.escape('Escaped? <.>');\r\n     * // -> 'Escaped\\?\\ <\\.>'\r\n     */\r\n    self.escape = function (str) {\r\n        return nativ.replace.call(str, /[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\r\n    };\r\n\r\n    /**\r\n     * Executes a regex search in a specified string. Returns a match array or `null`. If the provided\r\n     * regex uses named capture, named backreference properties are included on the match array.\r\n     * Optional `pos` and `sticky` arguments specify the search start position, and whether the match\r\n     * must start at the specified position only. The `lastIndex` property of the provided regex is not\r\n     * used, but is updated for compatibility. Also fixes browser bugs compared to the native\r\n     * `RegExp.prototype.exec` and can be used reliably cross-browser.\r\n     * @memberOf XRegExp\r\n     * @param {String} str String to search.\r\n     * @param {RegExp} regex Regex to search with.\r\n     * @param {Number} [pos=0] Zero-based index at which to start the search.\r\n     * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\r\n     *   only. The string `'sticky'` is accepted as an alternative to `true`.\r\n     * @return {Array} Match array with named backreference properties, or null.\r\n     * @example\r\n     *\r\n     * // Basic use, with named backreference\r\n     * var match = XRegExp.exec('U+2620', XRegExp('U\\\\+(?<hex>[0-9A-F]{4})'));\r\n     * match.hex; // -> '2620'\r\n     *\r\n     * // With pos and sticky, in a loop\r\n     * var pos = 2, r = [], match;\r\n     * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\\d)>/, pos, 'sticky')) {\r\n     *   r.push(match[1]);\r\n     *   pos = match.index + match[0].length;\r\n     * }\r\n     * // r -> ['2', '3', '4']\r\n     */\r\n    self.exec = function (str, regex, pos, sticky) {\r\n        var r2 = copy(regex, \"g\" + (sticky && hasNativeY ? \"y\" : \"\"), (sticky === false ? \"y\" : \"\")),\r\n            match;\r\n        r2.lastIndex = pos = pos || 0;\r\n        match = fixed.exec.call(r2, str); // Fixed `exec` required for `lastIndex` fix, etc.\r\n        if (sticky && match && match.index !== pos) {\r\n            match = null;\r\n        }\r\n        if (regex.global) {\r\n            regex.lastIndex = match ? r2.lastIndex : 0;\r\n        }\r\n        return match;\r\n    };\r\n\r\n    /**\r\n     * Executes a provided function once per regex match.\r\n     * @memberOf XRegExp\r\n     * @param {String} str String to search.\r\n     * @param {RegExp} regex Regex to search with.\r\n     * @param {Function} callback Function to execute for each match. Invoked with four arguments:\r\n     *   <li>The match array, with named backreference properties.\r\n     *   <li>The zero-based match index.\r\n     *   <li>The string being traversed.\r\n     *   <li>The regex object being used to traverse the string.\r\n     * @param {*} [context] Object to use as `this` when executing `callback`.\r\n     * @return {*} Provided `context` object.\r\n     * @example\r\n     *\r\n     * // Extracts every other digit from a string\r\n     * XRegExp.forEach('1a2345', /\\d/, function (match, i) {\r\n     *   if (i % 2) this.push(+match[0]);\r\n     * }, []);\r\n     * // -> [2, 4]\r\n     */\r\n    self.forEach = function (str, regex, callback, context) {\r\n        var pos = 0,\r\n            i = -1,\r\n            match;\r\n        while ((match = self.exec(str, regex, pos))) {\r\n            callback.call(context, match, ++i, str, regex);\r\n            pos = match.index + (match[0].length || 1);\r\n        }\r\n        return context;\r\n    };\r\n\r\n    /**\r\n     * Copies a regex object and adds flag `g`. The copy maintains special properties for named\r\n     * capture, is augmented with `XRegExp.prototype` methods, and has a fresh `lastIndex` property\r\n     * (set to zero). Native regexes are not recompiled using XRegExp syntax.\r\n     * @memberOf XRegExp\r\n     * @param {RegExp} regex Regex to globalize.\r\n     * @return {RegExp} Copy of the provided regex with flag `g` added.\r\n     * @example\r\n     *\r\n     * var globalCopy = XRegExp.globalize(/regex/);\r\n     * globalCopy.global; // -> true\r\n     */\r\n    self.globalize = function (regex) {\r\n        return copy(regex, \"g\");\r\n    };\r\n\r\n    /**\r\n     * Installs optional features according to the specified options.\r\n     * @memberOf XRegExp\r\n     * @param {Object|String} options Options object or string.\r\n     * @example\r\n     *\r\n     * // With an options object\r\n     * XRegExp.install({\r\n     *   // Overrides native regex methods with fixed/extended versions that support named\r\n     *   // backreferences and fix numerous cross-browser bugs\r\n     *   natives: true,\r\n     *\r\n     *   // Enables extensibility of XRegExp syntax and flags\r\n     *   extensibility: true\r\n     * });\r\n     *\r\n     * // With an options string\r\n     * XRegExp.install('natives extensibility');\r\n     *\r\n     * // Using a shortcut to install all optional features\r\n     * XRegExp.install('all');\r\n     */\r\n    self.install = function (options) {\r\n        options = prepareOptions(options);\r\n        if (!features.natives && options.natives) {\r\n            setNatives(true);\r\n        }\r\n        if (!features.extensibility && options.extensibility) {\r\n            setExtensibility(true);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Checks whether an individual optional feature is installed.\r\n     * @memberOf XRegExp\r\n     * @param {String} feature Name of the feature to check. One of:\r\n     *   <li>`natives`\r\n     *   <li>`extensibility`\r\n     * @return {Boolean} Whether the feature is installed.\r\n     * @example\r\n     *\r\n     * XRegExp.isInstalled('natives');\r\n     */\r\n    self.isInstalled = function (feature) {\r\n        return !!(features[feature]);\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes\r\n     * created in another frame, when `instanceof` and `constructor` checks would fail.\r\n     * @memberOf XRegExp\r\n     * @param {*} value Object to check.\r\n     * @return {Boolean} Whether the object is a `RegExp` object.\r\n     * @example\r\n     *\r\n     * XRegExp.isRegExp('string'); // -> false\r\n     * XRegExp.isRegExp(/regex/i); // -> true\r\n     * XRegExp.isRegExp(RegExp('^', 'm')); // -> true\r\n     * XRegExp.isRegExp(XRegExp('(?s).')); // -> true\r\n     */\r\n    self.isRegExp = function (value) {\r\n        return isType(value, \"regexp\");\r\n    };\r\n\r\n    /**\r\n     * Retrieves the matches from searching a string using a chain of regexes that successively search\r\n     * within previous matches. The provided `chain` array can contain regexes and objects with `regex`\r\n     * and `backref` properties. When a backreference is specified, the named or numbered backreference\r\n     * is passed forward to the next regex or returned.\r\n     * @memberOf XRegExp\r\n     * @param {String} str String to search.\r\n     * @param {Array} chain Regexes that each search for matches within preceding results.\r\n     * @return {Array} Matches by the last regex in the chain, or an empty array.\r\n     * @example\r\n     *\r\n     * // Basic usage; matches numbers within <b> tags\r\n     * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [\r\n     *   XRegExp('(?is)<b>.*?</b>'),\r\n     *   /\\d+/\r\n     * ]);\r\n     * // -> ['2', '4', '56']\r\n     *\r\n     * // Passing forward and returning specific backreferences\r\n     * html = '<a href=\"http://xregexp.com/api/\">XRegExp</a>\\\r\n     *         <a href=\"http://www.google.com/\">Google</a>';\r\n     * XRegExp.matchChain(html, [\r\n     *   {regex: /<a href=\"([^\"]+)\">/i, backref: 1},\r\n     *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}\r\n     * ]);\r\n     * // -> ['xregexp.com', 'www.google.com']\r\n     */\r\n    self.matchChain = function (str, chain) {\r\n        return (function recurseChain(values, level) {\r\n            var item = chain[level].regex ? chain[level] : { regex: chain[level] },\r\n                matches = [],\r\n                addMatch = function (match) {\r\n                    matches.push(item.backref ? (match[item.backref] || \"\") : match[0]);\r\n                },\r\n                i;\r\n            for (i = 0; i < values.length; ++i) {\r\n                self.forEach(values[i], item.regex, addMatch);\r\n            }\r\n            return ((level === chain.length - 1) || !matches.length) ?\r\n                matches :\r\n                    recurseChain(matches, level + 1);\r\n        }([str], 0));\r\n    };\r\n\r\n    /**\r\n     * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string\r\n     * or regex, and the replacement can be a string or a function to be called for each match. To\r\n     * perform a global search and replace, use the optional `scope` argument or include flag `g` if\r\n     * using a regex. Replacement strings can use `${n}` for named and numbered backreferences.\r\n     * Replacement functions can use named backreferences via `arguments[0].name`. Also fixes browser\r\n     * bugs compared to the native `String.prototype.replace` and can be used reliably cross-browser.\r\n     * @memberOf XRegExp\r\n     * @param {String} str String to search.\r\n     * @param {RegExp|String} search Search pattern to be replaced.\r\n     * @param {String|Function} replacement Replacement string or a function invoked to create it.\r\n     *   Replacement strings can include special replacement syntax:\r\n     *     <li>$$ - Inserts a literal '$'.\r\n     *     <li>$&, $0 - Inserts the matched substring.\r\n     *     <li>$` - Inserts the string that precedes the matched substring (left context).\r\n     *     <li>$' - Inserts the string that follows the matched substring (right context).\r\n     *     <li>$n, $nn - Where n/nn are digits referencing an existent capturing group, inserts\r\n     *       backreference n/nn.\r\n     *     <li>${n} - Where n is a name or any number of digits that reference an existent capturing\r\n     *       group, inserts backreference n.\r\n     *   Replacement functions are invoked with three or more arguments:\r\n     *     <li>The matched substring (corresponds to $& above). Named backreferences are accessible as\r\n     *       properties of this first argument.\r\n     *     <li>0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).\r\n     *     <li>The zero-based index of the match within the total search string.\r\n     *     <li>The total string being searched.\r\n     * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not\r\n     *   explicitly specified and using a regex with flag `g`, `scope` is 'all'.\r\n     * @return {String} New string with one or all matches replaced.\r\n     * @example\r\n     *\r\n     * // Regex search, using named backreferences in replacement string\r\n     * var name = XRegExp('(?<first>\\\\w+) (?<last>\\\\w+)');\r\n     * XRegExp.replace('John Smith', name, '${last}, ${first}');\r\n     * // -> 'Smith, John'\r\n     *\r\n     * // Regex search, using named backreferences in replacement function\r\n     * XRegExp.replace('John Smith', name, function (match) {\r\n     *   return match.last + ', ' + match.first;\r\n     * });\r\n     * // -> 'Smith, John'\r\n     *\r\n     * // Global string search/replacement\r\n     * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');\r\n     * // -> 'XRegExp builds XRegExps'\r\n     */\r\n    self.replace = function (str, search, replacement, scope) {\r\n        var isRegex = self.isRegExp(search),\r\n            search2 = search,\r\n            r;\r\n        if (isRegex) {\r\n            if (scope === undef && search.global) {\r\n                scope = \"all\"; // Follow flag g when `scope` isn't explicit\r\n            }\r\n            // Note that since a copy is used, `search`'s `lastIndex` isn't updated *during* replacement iterations\r\n            search2 = copy(search, scope === \"all\" ? \"g\" : \"\", scope === \"all\" ? \"\" : \"g\");\r\n        } else if (scope === \"all\") {\r\n            search2 = new RegExp(self.escape(String(search)), \"g\");\r\n        }\r\n        r = fixed.replace.call(String(str), search2, replacement); // Fixed `replace` required for named backreferences, etc.\r\n        if (isRegex && search.global) {\r\n            search.lastIndex = 0; // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\r\n        }\r\n        return r;\r\n    };\r\n\r\n    /**\r\n     * Splits a string into an array of strings using a regex or string separator. Matches of the\r\n     * separator are not included in the r array. However, if `separator` is a regex that contains\r\n     * capturing groups, backreferences are spliced into the r each time `separator` is matched.\r\n     * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\r\n     * cross-browser.\r\n     * @memberOf XRegExp\r\n     * @param {String} str String to split.\r\n     * @param {RegExp|String} separator Regex or string to use for separating the string.\r\n     * @param {Number} [limit] Maximum number of items to include in the r array.\r\n     * @return {Array} Array of substrings.\r\n     * @example\r\n     *\r\n     * // Basic use\r\n     * XRegExp.split('a b c', ' ');\r\n     * // -> ['a', 'b', 'c']\r\n     *\r\n     * // With limit\r\n     * XRegExp.split('a b c', ' ', 2);\r\n     * // -> ['a', 'b']\r\n     *\r\n     * // Backreferences in r array\r\n     * XRegExp.split('..word1..', /([a-z]+)(\\d+)/i);\r\n     * // -> ['..', 'word', '1', '..']\r\n     */\r\n    self.split = function (str, separator, limit) {\r\n        return fixed.split.call(str, separator, limit);\r\n    };\r\n\r\n    /**\r\n     * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and\r\n     * `sticky` arguments specify the search start position, and whether the match must start at the\r\n     * specified position only. The `lastIndex` property of the provided regex is not used, but is\r\n     * updated for compatibility. Also fixes browser bugs compared to the native\r\n     * `RegExp.prototype.test` and can be used reliably cross-browser.\r\n     * @memberOf XRegExp\r\n     * @param {String} str String to search.\r\n     * @param {RegExp} regex Regex to search with.\r\n     * @param {Number} [pos=0] Zero-based index at which to start the search.\r\n     * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\r\n     *   only. The string `'sticky'` is accepted as an alternative to `true`.\r\n     * @return {Boolean} Whether the regex matched the provided value.\r\n     * @example\r\n     *\r\n     * // Basic use\r\n     * XRegExp.test('abc', /c/); // -> true\r\n     *\r\n     * // With pos and sticky\r\n     * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false\r\n     */\r\n    self.test = function (str, regex, pos, sticky) {\r\n        // Do this the easy way :-)\r\n        return !!self.exec(str, regex, pos, sticky);\r\n    };\r\n\r\n    /**\r\n     * Uninstalls optional features according to the specified options.\r\n     * @memberOf XRegExp\r\n     * @param {Object|String} options Options object or string.\r\n     * @example\r\n     *\r\n     * // With an options object\r\n     * XRegExp.uninstall({\r\n     *   // Restores native regex methods\r\n     *   natives: true,\r\n     *\r\n     *   // Disables additional syntax and flag extensions\r\n     *   extensibility: true\r\n     * });\r\n     *\r\n     * // With an options string\r\n     * XRegExp.uninstall('natives extensibility');\r\n     *\r\n     * // Using a shortcut to uninstall all optional features\r\n     * XRegExp.uninstall('all');\r\n     */\r\n    self.uninstall = function (options) {\r\n        options = prepareOptions(options);\r\n        if (features.natives && options.natives) {\r\n            setNatives(false);\r\n        }\r\n        if (features.extensibility && options.extensibility) {\r\n            setExtensibility(false);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as\r\n     * regex objects or strings. Metacharacters are escaped in patterns provided as strings.\r\n     * Backreferences in provided regex objects are automatically renumbered to work correctly. Native\r\n     * flags used by provided regexes are ignored in favor of the `flags` argument.\r\n     * @memberOf XRegExp\r\n     * @param {Array} patterns Regexes and strings to combine.\r\n     * @param {String} [flags] Any combination of XRegExp flags.\r\n     * @return {RegExp} Union of the provided regexes and strings.\r\n     * @example\r\n     *\r\n     * XRegExp.union(['a+b*c', /(dogs)\\1/, /(cats)\\1/], 'i');\r\n     * // -> /a\\+b\\*c|(dogs)\\1|(cats)\\2/i\r\n     *\r\n     * XRegExp.union([XRegExp('(?<pet>dogs)\\\\k<pet>'), XRegExp('(?<pet>cats)\\\\k<pet>')]);\r\n     * // -> XRegExp('(?<pet>dogs)\\\\k<pet>|(?<pet>cats)\\\\k<pet>')\r\n     */\r\n    self.union = function (patterns, flags) {\r\n        var parts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*]/g,\r\n            numCaptures = 0,\r\n            numPriorCaptures,\r\n            captureNames,\r\n            rewrite = function (match, paren, backref) {\r\n                var name = captureNames[numCaptures - numPriorCaptures];\r\n                if (paren) { // Capturing group\r\n                    ++numCaptures;\r\n                    if (name) { // If the current capture has a name\r\n                        return \"(?<\" + name + \">\";\r\n                    }\r\n                } else if (backref) { // Backreference\r\n                    return \"\\\\\" + (+backref + numPriorCaptures);\r\n                }\r\n                return match;\r\n            },\r\n            output = [],\r\n            pattern,\r\n            i;\r\n        if (!(isType(patterns, \"array\") && patterns.length)) {\r\n            throw new TypeError(\"patterns must be a nonempty array\");\r\n        }\r\n        for (i = 0; i < patterns.length; ++i) {\r\n            pattern = patterns[i];\r\n            if (self.isRegExp(pattern)) {\r\n                numPriorCaptures = numCaptures;\r\n                captureNames = (pattern.xregexp && pattern.xregexp.captureNames) || [];\r\n                // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns\r\n                // are independently valid; helps keep this simple. Named captures are put back\r\n                output.push(self(pattern.source).source.replace(parts, rewrite));\r\n            } else {\r\n                output.push(self.escape(pattern));\r\n            }\r\n        }\r\n        return self(output.join(\"|\"), flags);\r\n    };\r\n\r\n    /**\r\n     * The XRegExp version number.\r\n     * @static\r\n     * @memberOf XRegExp\r\n     * @type String\r\n     */\r\n    self.version = \"2.0.0\";\r\n\r\n    /*--------------------------------------\r\n     *  Fixed/extended native methods\r\n     *------------------------------------*/\r\n\r\n    /**\r\n     * Adds named capture support (with backreferences returned as `r.name`), and fixes browser\r\n     * bugs in the native `RegExp.prototype.exec`. Calling `XRegExp.install('natives')` uses this to\r\n     * override the native method. Use via `XRegExp.exec` without overriding natives.\r\n     * @private\r\n     * @param {String} str String to search.\r\n     * @return {Array} Match array with named backreference properties, or null.\r\n     */\r\n    fixed.exec = function (str) {\r\n        var match, name, r2, origLastIndex, i;\r\n        if (!this.global) {\r\n            origLastIndex = this.lastIndex;\r\n        }\r\n        match = nativ.exec.apply(this, arguments);\r\n        if (match) {\r\n            // Fix browsers whose `exec` methods don't consistently return `undefined` for\r\n            // nonparticipating capturing groups\r\n            if (!compliantExecNpcg && match.length > 1 && lastIndexOf(match, \"\") > -1) {\r\n                r2 = new RegExp(this.source, nativ.replace.call(getNativeFlags(this), \"g\", \"\"));\r\n                // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed\r\n                // matching due to characters outside the match\r\n                nativ.replace.call(String(str).slice(match.index), r2, function () {\r\n                    var i;\r\n                    for (i = 1; i < arguments.length - 2; ++i) {\r\n                        if (arguments[i] === undef) {\r\n                            match[i] = undef;\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            // Attach named capture properties\r\n            if (this.xregexp && this.xregexp.captureNames) {\r\n                for (i = 1; i < match.length; ++i) {\r\n                    name = this.xregexp.captureNames[i - 1];\r\n                    if (name) {\r\n                        match[name] = match[i];\r\n                    }\r\n                }\r\n            }\r\n            // Fix browsers that increment `lastIndex` after zero-length matches\r\n            if (this.global && !match[0].length && (this.lastIndex > match.index)) {\r\n                this.lastIndex = match.index;\r\n            }\r\n        }\r\n        if (!this.global) {\r\n            this.lastIndex = origLastIndex; // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\r\n        }\r\n        return match;\r\n    };\r\n\r\n    /**\r\n     * Fixes browser bugs in the native `RegExp.prototype.test`. Calling `XRegExp.install('natives')`\r\n     * uses this to override the native method.\r\n     * @private\r\n     * @param {String} str String to search.\r\n     * @return {Boolean} Whether the regex matched the provided value.\r\n     */\r\n    fixed.test = function (str) {\r\n        // Do this the easy way :-)\r\n        return !!fixed.exec.call(this, str);\r\n    };\r\n\r\n    /**\r\n     * Adds named capture support (with backreferences returned as `r.name`), and fixes browser\r\n     * bugs in the native `String.prototype.match`. Calling `XRegExp.install('natives')` uses this to\r\n     * override the native method.\r\n     * @private\r\n     * @param {RegExp} regex Regex to search with.\r\n     * @return {Array} If `regex` uses flag g, an array of match strings or null. Without flag g, the\r\n     *   r of calling `regex.exec(this)`.\r\n     */\r\n    fixed.match = function (regex) {\r\n        if (!self.isRegExp(regex)) {\r\n            regex = new RegExp(regex); // Use native `RegExp`\r\n        } else if (regex.global) {\r\n            var r = nativ.match.apply(this, arguments);\r\n            regex.lastIndex = 0; // Fixes IE bug\r\n            return r;\r\n        }\r\n        return fixed.exec.call(regex, this);\r\n    };\r\n\r\n    /**\r\n     * Adds support for `${n}` tokens for named and numbered backreferences in replacement text, and\r\n     * provides named backreferences to replacement functions as `arguments[0].name`. Also fixes\r\n     * browser bugs in replacement text syntax when performing a replacement using a nonregex search\r\n     * value, and the value of a replacement regex's `lastIndex` property during replacement iterations\r\n     * and upon completion. Note that this doesn't support SpiderMonkey's proprietary third (`flags`)\r\n     * argument. Calling `XRegExp.install('natives')` uses this to override the native method. Use via\r\n     * `XRegExp.replace` without overriding natives.\r\n     * @private\r\n     * @param {RegExp|String} search Search pattern to be replaced.\r\n     * @param {String|Function} replacement Replacement string or a function invoked to create it.\r\n     * @return {String} New string with one or all matches replaced.\r\n     */\r\n    fixed.replace = function (search, replacement) {\r\n        var isRegex = self.isRegExp(search), captureNames, r, str, origLastIndex;\r\n        if (isRegex) {\r\n            if (search.xregexp) {\r\n                captureNames = search.xregexp.captureNames;\r\n            }\r\n            if (!search.global) {\r\n                origLastIndex = search.lastIndex;\r\n            }\r\n        } else {\r\n            search += \"\";\r\n        }\r\n        if (isType(replacement, \"function\")) {\r\n            r = nativ.replace.call(String(this), search, function () {\r\n                var args = arguments, i;\r\n                if (captureNames) {\r\n                    // Change the `arguments[0]` string primitive to a `String` object that can store properties\r\n                    args[0] = new String(args[0]);\r\n                    // Store named backreferences on the first argument\r\n                    for (i = 0; i < captureNames.length; ++i) {\r\n                        if (captureNames[i]) {\r\n                            args[0][captureNames[i]] = args[i + 1];\r\n                        }\r\n                    }\r\n                }\r\n                // Update `lastIndex` before calling `replacement`.\r\n                // Fixes IE, Chrome, Firefox, Safari bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)\r\n                if (isRegex && search.global) {\r\n                    search.lastIndex = args[args.length - 2] + args[0].length;\r\n                }\r\n                return replacement.apply(null, args);\r\n            });\r\n        } else {\r\n            str = String(this); // Ensure `args[args.length - 1]` will be a string when given nonstring `this`\r\n            r = nativ.replace.call(str, search, function () {\r\n                var args = arguments; // Keep this function's `arguments` available through closure\r\n                return nativ.replace.call(String(replacement), replacementToken, function ($0, $1, $2) {\r\n                    var n;\r\n                    // Named or numbered backreference with curly brackets\r\n                    if ($1) {\r\n                        /* XRegExp behavior for `${n}`:\r\n                         * 1. Backreference to numbered capture, where `n` is 1+ digits. `0`, `00`, etc. is the entire match.\r\n                         * 2. Backreference to named capture `n`, if it exists and is not a number overridden by numbered capture.\r\n                         * 3. Otherwise, it's an error.\r\n                         */\r\n                        n = +$1; // Type-convert; drop leading zeros\r\n                        if (n <= args.length - 3) {\r\n                            return args[n] || \"\";\r\n                        }\r\n                        n = captureNames ? lastIndexOf(captureNames, $1) : -1;\r\n                        if (n < 0) {\r\n                            throw new SyntaxError(\"backreference to undefined group \" + $0);\r\n                        }\r\n                        return args[n + 1] || \"\";\r\n                    }\r\n                    // Else, special variable or numbered backreference (without curly brackets)\r\n                    if ($2 === \"$\") return \"$\";\r\n                    if ($2 === \"&\" || +$2 === 0) return args[0]; // $&, $0 (not followed by 1-9), $00\r\n                    if ($2 === \"`\") return args[args.length - 1].slice(0, args[args.length - 2]);\r\n                    if ($2 === \"'\") return args[args.length - 1].slice(args[args.length - 2] + args[0].length);\r\n                    // Else, numbered backreference (without curly brackets)\r\n                    $2 = +$2; // Type-convert; drop leading zero\r\n                    /* XRegExp behavior:\r\n                     * - Backreferences without curly brackets end after 1 or 2 digits. Use `${..}` for more digits.\r\n                     * - `$1` is an error if there are no capturing groups.\r\n                     * - `$10` is an error if there are less than 10 capturing groups. Use `${1}0` instead.\r\n                     * - `$01` is equivalent to `$1` if a capturing group exists, otherwise it's an error.\r\n                     * - `$0` (not followed by 1-9), `$00`, and `$&` are the entire match.\r\n                     * Native behavior, for comparison:\r\n                     * - Backreferences end after 1 or 2 digits. Cannot use backreference to capturing group 100+.\r\n                     * - `$1` is a literal `$1` if there are no capturing groups.\r\n                     * - `$10` is `$1` followed by a literal `0` if there are less than 10 capturing groups.\r\n                     * - `$01` is equivalent to `$1` if a capturing group exists, otherwise it's a literal `$01`.\r\n                     * - `$0` is a literal `$0`. `$&` is the entire match.\r\n                     */\r\n                    if (!isNaN($2)) {\r\n                        if ($2 > args.length - 3) {\r\n                            throw new SyntaxError(\"backreference to undefined group \" + $0);\r\n                        }\r\n                        return args[$2] || \"\";\r\n                    }\r\n                    throw new SyntaxError(\"invalid token \" + $0);\r\n                });\r\n            });\r\n        }\r\n        if (isRegex) {\r\n            if (search.global) {\r\n                search.lastIndex = 0; // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\r\n            } else {\r\n                search.lastIndex = origLastIndex; // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\r\n            }\r\n        }\r\n        return r;\r\n    };\r\n\r\n    /**\r\n     * Fixes browser bugs in the native `String.prototype.split`. Calling `XRegExp.install('natives')`\r\n     * uses this to override the native method. Use via `XRegExp.split` without overriding natives.\r\n     * @private\r\n     * @param {RegExp|String} separator Regex or string to use for separating the string.\r\n     * @param {Number} [limit] Maximum number of items to include in the r array.\r\n     * @return {Array} Array of substrings.\r\n     */\r\n    fixed.split = function (separator, limit) {\r\n        if (!self.isRegExp(separator)) {\r\n            return nativ.split.apply(this, arguments); // use faster native method\r\n        }\r\n        var str = String(this),\r\n            origLastIndex = separator.lastIndex,\r\n            output = [],\r\n            lastLastIndex = 0,\r\n            lastLength;\r\n        /* Values for `limit`, per the spec:\r\n         * If undefined: pow(2,32) - 1\r\n         * If 0, Infinity, or NaN: 0\r\n         * If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);\r\n         * If negative number: pow(2,32) - floor(abs(limit))\r\n         * If other: Type-convert, then use the above rules\r\n         */\r\n        limit = (limit === undef ? -1 : limit) >>> 0;\r\n        self.forEach(str, separator, function (match) {\r\n            if ((match.index + match[0].length) > lastLastIndex) { // != `if (match[0].length)`\r\n                output.push(str.slice(lastLastIndex, match.index));\r\n                if (match.length > 1 && match.index < str.length) {\r\n                    Array.prototype.push.apply(output, match.slice(1));\r\n                }\r\n                lastLength = match[0].length;\r\n                lastLastIndex = match.index + lastLength;\r\n            }\r\n        });\r\n        if (lastLastIndex === str.length) {\r\n            if (!nativ.test.call(separator, \"\") || lastLength) {\r\n                output.push(\"\");\r\n            }\r\n        } else {\r\n            output.push(str.slice(lastLastIndex));\r\n        }\r\n        separator.lastIndex = origLastIndex;\r\n        return output.length > limit ? output.slice(0, limit) : output;\r\n    };\r\n\r\n    /*--------------------------------------\r\n     *  Built-in tokens\r\n     *------------------------------------*/\r\n\r\n    // Shortcut\r\n    add = addToken.on;\r\n\r\n    /* Letter identity escapes that natively match literal characters: \\p, \\P, etc.\r\n     * Should be SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-\r\n     * browser consistency and to reserve their syntax, but lets them be superseded by XRegExp addons.\r\n     */\r\n    add(/\\\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\\dA-Fa-f]{4})|x(?![\\dA-Fa-f]{2}))/,\r\n        function (match, scope) {\r\n            // \\B is allowed in default scope only\r\n            if (match[1] === \"B\" && scope === defaultScope) {\r\n                return match[0];\r\n            }\r\n            throw new SyntaxError(\"invalid escape \" + match[0]);\r\n        },\r\n        { scope: \"all\" });\r\n\r\n    /* Empty character class: [] or [^]\r\n     * Fixes a critical cross-browser syntax inconsistency. Unless this is standardized (per the spec),\r\n     * regex syntax can't be accurately parsed because character class endings can't be determined.\r\n     */\r\n    add(/\\[(\\^?)]/,\r\n        function (match) {\r\n            // For cross-browser compatibility with ES3, convert [] to \\b\\B and [^] to [\\s\\S].\r\n            // (?!) should work like \\b\\B, but is unreliable in Firefox\r\n            return match[1] ? \"[\\\\s\\\\S]\" : \"\\\\b\\\\B\";\r\n        });\r\n\r\n    /* Comment pattern: (?# )\r\n     * Inline comments are an alternative to the line comments allowed in free-spacing mode (flag x).\r\n     */\r\n    add(/(?:\\(\\?#[^)]*\\))+/,\r\n        function (match) {\r\n            // Keep tokens separated unless the following token is a quantifier\r\n            return nativ.test.call(quantifier, match.input.slice(match.index + match[0].length)) ? \"\" : \"(?:)\";\r\n        });\r\n\r\n    /* Named backreference: \\k<name>\r\n     * Backreference names can use the characters A-Z, a-z, 0-9, _, and $ only.\r\n     */\r\n    add(/\\\\k<([\\w$]+)>/,\r\n        function (match) {\r\n            var index = isNaN(match[1]) ? (lastIndexOf(this.captureNames, match[1]) + 1) : +match[1],\r\n                endIndex = match.index + match[0].length;\r\n            if (!index || index > this.captureNames.length) {\r\n                throw new SyntaxError(\"backreference to undefined group \" + match[0]);\r\n            }\r\n            // Keep backreferences separate from subsequent literal numbers\r\n            return \"\\\\\" + index + (\r\n                endIndex === match.input.length || isNaN(match.input.charAt(endIndex)) ? \"\" : \"(?:)\"\r\n            );\r\n        });\r\n\r\n    /* Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.\r\n     */\r\n    add(/(?:\\s+|#.*)+/,\r\n        function (match) {\r\n            // Keep tokens separated unless the following token is a quantifier\r\n            return nativ.test.call(quantifier, match.input.slice(match.index + match[0].length)) ? \"\" : \"(?:)\";\r\n        },\r\n        {\r\n            trigger: function () {\r\n                return this.hasFlag(\"x\");\r\n            },\r\n            customFlags: \"x\"\r\n        });\r\n\r\n    /* Dot, in dotall mode (aka singleline mode, flag s) only.\r\n     */\r\n    add(/\\./,\r\n        function () {\r\n            return \"[\\\\s\\\\S]\";\r\n        },\r\n        {\r\n            trigger: function () {\r\n                return this.hasFlag(\"s\");\r\n            },\r\n            customFlags: \"s\"\r\n        });\r\n\r\n    /* Named capturing group; match the opening delimiter only: (?<name>\r\n     * Capture names can use the characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers.\r\n     * Supports Python-style (?P<name> as an alternate syntax to avoid issues in recent Opera (which\r\n     * natively supports the Python-style syntax). Otherwise, XRegExp might treat numbered\r\n     * backreferences to Python-style named capture as octals.\r\n     */\r\n    add(/\\(\\?P?<([\\w$]+)>/,\r\n        function (match) {\r\n            if (!isNaN(match[1])) {\r\n                // Avoid incorrect lookups, since named backreferences are added to match arrays\r\n                throw new SyntaxError(\"can't use integer as capture name \" + match[0]);\r\n            }\r\n            this.captureNames.push(match[1]);\r\n            this.hasNamedCapture = true;\r\n            return \"(\";\r\n        });\r\n\r\n    /* Numbered backreference or octal, plus any following digits: \\0, \\11, etc.\r\n     * Octals except \\0 not followed by 0-9 and backreferences to unopened capture groups throw an\r\n     * error. Other matches are returned unaltered. IE <= 8 doesn't support backreferences greater than\r\n     * \\99 in regex syntax.\r\n     */\r\n    add(/\\\\(\\d+)/,\r\n        function (match, scope) {\r\n            if (!(scope === defaultScope && /^[1-9]/.test(match[1]) && +match[1] <= this.captureNames.length) &&\r\n                    match[1] !== \"0\") {\r\n                throw new SyntaxError(\"can't use octal escape or backreference to undefined group \" + match[0]);\r\n            }\r\n            return match[0];\r\n        },\r\n        { scope: \"all\" });\r\n\r\n    /* Capturing group; match the opening parenthesis only.\r\n     * Required for support of named capturing groups. Also adds explicit capture mode (flag n).\r\n     */\r\n    add(/\\((?!\\?)/,\r\n        function () {\r\n            if (this.hasFlag(\"n\")) {\r\n                return \"(?:\";\r\n            }\r\n            this.captureNames.push(null);\r\n            return \"(\";\r\n        },\r\n        { customFlags: \"n\" });\r\n\r\n    /*--------------------------------------\r\n     *  Expose XRegExp\r\n     *------------------------------------*/\r\n\r\n    // For CommonJS enviroments\r\n    if (typeof exports !== \"undefined\") {\r\n        exports.XRegExp = self;\r\n    }\r\n\r\n    return self;\r\n\r\n}());\r\n\r\nexport default XRegExp;"],"mappings":"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"}