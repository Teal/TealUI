
var Path = require('path'),
	Url = require('url'),
	IO = require('utilskit/io'),
	UglifyJS = require('uglify-js'),
	Helpers = require('utilskit/helpers');

// A small hack for UglifyJS to remove node.
	
function NoneStatement(){
	
}

NoneStatement.prototype = new UglifyJS.AST_SimpleStatement;

NoneStatement.prototype.print = function(self, output){
	if(!self._semicolon) {
		self._semicolon = self.semicolon;
		self.semicolon = function(){
			this.semicolon = this._semicolon;
			delete this._semicolon;
		};
	}
};

// A simple string stream.

function StringStream() {
    this.outputs = [];
}

StringStream.prototype.write = function (value) {
    this.outputs.push(value);
};

StringStream.prototype.end = function () {
    return this.outputs.join('');
};

// Parsers API

function Module(builder, modulePath, filePath, extension, content) {
	this.builder = builder;
	this.modulePath = modulePath;
	this.filePath = filePath;
	this.extension = extension;
	this.content = content;

	this.included = [];
	this.excluded = [];
	this.directlyIncluded = [];
	this.virtualExcluded = [];

}

Module.prototype = {
    builder: null,
    modulePath: null,
    filePath: null,
    extension: null,
    content: null,

    output: null,
    included: null,
    excluded: null,
    directlyIncluded: null,
	virtualExcluded: null,

	/**
	 * Add an refenrence module of current module.
	 */
	include: function (modulePath) {
	    var module = this.builder.getModuleByModulePath(modulePath);

	    copyItems(module.included, this.included);
	    copyItems(module.excluded, this.excluded);
	    copyItems(module.virtualExcluded, this.virtualExcluded);

	    this.included.push(module);
	    this.directlyIncluded.push(module);

	    return module;
	},

    /**
     * Exculde a path so that the specified path would be skipped by include.
     */
	exclude: function (modulePath) {
		var module = this.builder.getModuleByModulePath(modulePath);

		copyItems(module.included, this.excluded);
		copyItems(module.excluded, this.excluded);

		this.excluded.push(module);

		return module;
	},

    /**
     * Exports a varName so that AMD loaders are able to load current file as a module.
     */
	exports: function (varName, varValue) {
		this.exportsConfigs = [varName, varValue];
	},

	getRefs: function () {
	    var refs = {};
	    this.included.push(this);
	    for (var i = 0; i < this.included.length; i++) {
	        var module = this.included[i];
	        if (this.excluded.indexOf(module) === -1) {
	            if (refs[module.extension]) {
	                refs[module.extension].push(module);
	            } else {
	                refs[module.extension] = [module];
	            }
	        }
	    }

	    this.included.pop();

	    return refs;
	},

	getStream: function (path) {
	    if (typeof path === 'string') {
	        return IO.openWrite(path, {
	            flags: 'w',
	            encoding: this.builder.toEncoding,
	            mode: 0666
	        });
	    } else {
	        return new StringStream();
	    }
	},

	_printRefs: function (stream, refs) {
	    for (var i = 0; i < refs.length; i++) {
	        this.builder.writeModulePath(stream, refs[i].modulePath);
	        stream.write(refs[i].output);
	    }
	},
    
	_printRefsWithoutModuleHeader: function (stream, refs) {
	    for (var i = 0; i < refs.length; i++) {
	        stream.write(refs[i].output);
	    }
	},

	_printHtml: function (stream, refs) {

	    if (refs[".html"]) {
	        var outputs = [];
	        for (var i = 0; i < refs[".html"].length; i++) {
	            outputs.push(refs[".html"][i].output);
	        }

	        stream.write('document.write(' + toJsString(outputs.join('')) + ');' + this.builder.lineBreak);
	    }

	},

	printAsSingleJs: function (path) {

	    var refs = this.getRefs();
	    var stream = this.getStream(path);
	    this.builder.writeGlobalComment(stream);

	    if (refs[".js"]) {
	        this.builder.writeJsExclude(stream, this);
	    }

	    if (refs[".css"]) {
	        var outputs = ['<style type="text/css">'];
	        for (var i = 0; i < refs[".css"].length; i++) {
	            outputs.push(refs[".css"][i].output);
	        }
	        outputs.push('</style>');

	        stream.write('document.write(' + toJsString(outputs.join('')) + ');' + this.builder.lineBreak);
	    }

	    if (refs[".js"]) {
	        this._printHtml(stream, refs);
	        this._printRefs(stream, refs[".js"]);
	    }

	    return stream.end();

	},

	printAsJsAndCss: function (js, css) {

	    var refs = this.getRefs();

	    if (refs[".js"]) {
	        var stream = this.getStream(js);
	        this.builder.writeGlobalComment(stream);
	        this.builder.writeJsExclude(stream, this);

	        this._printHtml(stream, refs);
	        this._printRefs(stream, refs[".js"]);
	    } else if (refs[".html"]) {
	        var stream = this.getStream(js);
	        this.builder.writeGlobalComment(stream);
	        this.builder.writeJsExclude(stream, this);

	        this._printHtml(stream, refs);
	    }

	    if (refs[".css"]) {
	        var stream2 = this.getStream(css);
	        this.builder.writeGlobalComment(stream2);
	        this._printRefs(stream2, refs[".css"]);
	    }

	    return [stream && stream.end(), stream2 && stream2.end()];

	},

	printAsSingleCss: function (path) {
        
	    var refs = this.getRefs();

	    if (refs[".css"]) {
	        var stream = this.getStream(css);
	        this.builder.writeGlobalComment(stream);
	        this._printRefs(stream, refs[".css"]);
	        return stream.end();
	    }

	},

	printAsSingleHtml: function (path) {
	    var refs = this.getRefs();
	    var stream = this.getStream(path, "finalJs");

	    if(refs[".css"]) {
	        stream.write('<style type="text/css">');
	        this._printRefsWithoutModuleHeader(stream, refs[".css"]);
	        stream.write('</style>');
	    }
        
	    if(refs[".html"]) {
	        this._printRefsWithoutModuleHeader(stream, refs[".html"]);
	    }
        
	    if(refs[".js"]) {
	        stream.write(this.scriptStart || "<script type=\"text/javascript\">");
	        this._printRefsWithoutModuleHeader(stream, refs[".js"]);
	        stream.write(this.scriptEnd || "</script>");
	    }
	    
	    return stream.end();

	}

};


/**
 * Parse Context to save any data.
 */
function Builder(configs) {

    Helpers.extend(this, configs);

    //if (typeof this.images === "string") {
    //    this.images = Path.resolve(this.images);
    //}

    //if (typeof this.js === "string") {
    //    this.js = Path.resolve(this.js);
    //}

    //if (typeof this.css === "string") {
    //    this.css = Path.resolve(this.css);
    //}

    //if (typeof this.html === "string") {
    //    this.html = Path.resolve(this.html);
    //}

    this.modules = {};

}


Builder.prototype = {

    /**
	 * The root path used by include. Default to the parent directory of boot.js.The path should not be end with "/".
	 */
    basePath: "",

    /**
	 * The current path used by include. Default to the directory of current page.The path should not be end with "/".
	 */
    currentPath: "",

    path: 'index',

    fromEncoding: "utf-8",

    toEncoding: "utf-8",

    lineBreak: "\r\n",

    js: null,

    css: null,

    images: null,

    info: function (content) {
        console.info(content);
    },

    infoFile: function (content, modulePath, path) {
        console.info(content);
    },

    log: function (content) {
        console.log(content);
    },

    error: function (content) {
        console.error(content);
    },

    debug: function (content) {
        console.log(content);
    },
    
    copyFile: function (fromUrl, fromFileRelated, toDirectory, toFileRelated){
		
        var fromPath = Path.resolve(Path.dirname(fromFileRelated), fromUrl);
        var toPath;
			
        if(toDirectory){
	        if(this.autoDetectImagePath !== false){
	            var t = fromPath
                    .replace(/\\/g, "/")
                    .replace("/assets/", "/")
                    .replace("/resources/", "/")
                    .replace("/images/", "/")
                    .replace("/img/", "/")
                    .replace("/imgs/", "/");
						
	            t = Path.relative(this.basePath, t);
						
	            toDirectory = Path.resolve(toDirectory, Path.basename(Path.dirname(t)));
	        }
	        toPath = Path.resolve(toDirectory, Path.basename(fromPath));
				
	        IO.copyFile(fromPath, toPath);
	    } else {
            toPath = fromPath;
	    }
			
	    return Path.relative(Path.dirname(toFileRelated), toPath).replace(/\\/g, "/");
	},
			
    /**
     * Callback that all parses are finished.
     */
	end: null,

	build: function () {

		// Get the current module.
	    var module = this.getModuleByFilePath(this.path);

	    if(this.js){

	    	// If js only. Combime all output in one file.
	        if (!this.css) {
	            module.printAsSingleJs(this.js);
	        } else {
	            module.printAsJsAndCss(this.js, this.css);
	    	}

	    } else if (this.css) {
	        module.printAsSingleCss(this.css);
	    }

	    if (module.extension === ".html" && this.html) {
	        module.printAsSingleHtml(this.html);
	    }


		if (this.end) {
		    this.end(module);
		}

		return module;
	},

	writeGlobalComment: function (stream) {
	    stream.write("/*********************************************************");
	    stream.write(this.lineBreak);
	    stream.write(" * ");
	    var d = new Date();
	    stream.write("This file is created by a tool at " + [d.getFullYear(), '/', d.getMonth() + 1, '/', d.getDate(), ' ', d.getHours(), ':', d.getMinutes()].join(''));
	    stream.write(this.lineBreak);
	    stream.write(" ********************************************************/");
	    stream.write(this.lineBreak);
	},

	writeModulePath: function (stream, modulePath) {
	    stream.write(this.lineBreak);
	    stream.write("/*********************************************************");
	    stream.write(this.lineBreak);
	    stream.write(" * ");
	    stream.write(modulePath);
	    stream.write(this.lineBreak);
	    stream.write(" ********************************************************/");
	    stream.write(this.lineBreak);
	},

	writeJsExclude: function(stream, module) {
	    stream.write('if(typeof exclude === "function") {');
	    for (var i = 0; i < module.included.length; i++) {
	        stream.write(this.lineBreak + '\texclude(' +  toJsString(module.included[i].modulePath) + ');');
	    }
	    for (var i = 0; i < module.virtualExcluded.length; i++) {
	        stream.write(this.lineBreak + '\texclude(' + toJsString(module.virtualExcluded[i].modulePath) + ');');
	    }
	    stream.write(this.lineBreak);
	    stream.write('}');
	    stream.write(this.lineBreak);
	},

	getModuleByFilePath: function (filePath) {
	    return this.getModuleByModulePath(this.toModulePath(filePath));
	},

	getModuleByModulePath: function (modulePath) {

	    var filePath = this.toFilePath(modulePath);

		// If the module is processed, do not load twice.
	    if (this.modules[filePath]) {
	        return this.modules[filePath];
		}

	    var module = this.modules[filePath] = new Module(this, modulePath, filePath, this.getExtension(filePath), IO.readFile(filePath, this.fromEncoding));

		// No sourceCode or file not exists, nothing parsed.
		if (module.content) {

			// Do load.
			this.loaders[module.extension](module);

		}
		return module;

	},

	/**
	 * Get the actually url of specified module path.
	 */
	toModulePath: function (filePath) {

	    return Path.relative(this.basePath, filePath).replace(/\\/g, "/");
	},

	/**
	 * Get the actually url of specified module path.
	 */
	toFilePath: function (modulePath) {

		// If modulePath starts with '~', replace '~' with current html path.
		// If modulePath is relative path. Concat modulePath with basePath.
		if (modulePath.substr(0, 2) === '~/') {
			modulePath = modulePath.replace('~/', (this.currentPath || this.basePath) + "/");
		} else if (!/:\/\//.test(modulePath)) {
			modulePath = this.basePath + "/" + modulePath;
		}

		if (!Path.extname(modulePath)) {
			modulePath += ".js";
		}

		return Path.normalize(modulePath);
	},

	/**
	 * Get the extension of specified url.
	 * @return {String} The extension that starts with a dot. If the actual 
	 * extension is not a member of include.fileExtensions, it returns ".html" 
	 * by default.
	 */
	getExtension: function (url) {
		var match = /\.\w+$/.exec(url);
		return match && (match[0] in this.loaders) ? match[0] : ".html";
	},

	/**
	 * All supported loaders for variant extensions.
	 */
	loaders: {
		'.js': function (module) {

			var builder = module.builder;
			var output;

			// Get the ast.

			try {

				var ast = UglifyJS.parse(module.content);

				var trans = new UglifyJS.TreeTransformer(function (node, descend) {
					if (node instanceof UglifyJS.AST_Call) {

						var funcName = node.start.value;

						if (funcName === 'include' && node.args[0] && node.args[0].value) {

							// Process include("path");

						    // Call module.include and return the ast object.
							module.include(node.args[0].value);

							return new NoneStatement();

						} else if (funcName === 'exclude' && node.args[0] && node.args[0].value) {

							// Process include("path");

						    // Call module.include and return the ast object.
							module.exclude(node.args[0].value);

							return new NoneStatement();
						} else if (builder.removeTrace && funcName === "trace") {


						} else if (builder.removeAssert && funcName === "assert") {


						}
					}
				});

				ast = ast.transform(trans);

				// Output the ast.
				module.output = printAstToString(ast, builder);

			} catch (e) {

			    builder.error("Parse File Error: " + e.toString() + ' (' + module.filePath + ')');

				module.output = module.content;
			}

		},

		'.html': function (module) {

			// Process inline scripts.
		    module.output = module.content.replace(/(<script[^>]*>)([\s\S]+?)(<\/script>)/ig, function (_, start, body, end) {

				// <script src>
				if (/(\bsrc\s*=\s*)(['"]?)[^'"]*?\2/.test(start)) {

				} else if(body) {
                    
					// Continue to parse inline scripts.
				    var virtualModule = new Module(module.builder, "", "", ".js", body);

				    virtualModule.scriptStart = start;
				    virtualModule.scriptEnd = end;

				    var oldCurrentPath = module.builder.currentPath;
				    virtualModule.builder.currentPath = Path.dirname(module.path);

				    virtualModule.builder.loaders[virtualModule.extension](virtualModule);
				    
				    copyItems(virtualModule.included, module.virtualExcluded);

				    try {

				        return virtualModule.printAsSingleHtml();

				    } finally {
				        virtualModule.builder.currentPath = oldCurrentPath;
				    }

				}

				return _;

			});

		},

		'.css': function (module) {

		    var output = module.content;

			// resolve css @import.
		    if (module.builder.resolveCssImport !== false) {
		        output = output.replace(/@import\s+url\s*\((['"]?)([^'"]*)\1\)/ig, function (_, q, url) {

					// Do not process absolute path
					if (url.indexOf(':') >= 0)
					    return _;

					var sourceFile = Path.resolve(Path.dirname(path), url);

					var virtualModule = module.include(module.builder.toModulePath(sourceFile));

					return virtualModule.output;
				});
			}

			// resolve images.
		    if (module.builder.resolveCssImages !== false) {
			    output = output.replace(/(url\s*\((['""]?))(.*)(\2\))/ig, function (_, left, q, url, right) {

					// Do not process absolute path
					if (url.indexOf(':') >= 0)
						return _;

					var newFileRelated = module.builder.css || module.builder.html || module.builder.basePath;
					
					var newUrl = module.builder.copyFile(url, module.filePath, module.builder.images, newFileRelated);

					if (newUrl) {
						return left + newUrl + right;
					}

					return _;
				});
			}

			module.output = output;

		}
	}


};

exports.Module = Module;
exports.Builder = Builder;

/**
 * Remove the include command in sourceCode.
 */
exports.build = function (configs) {

	var builder = new Builder(configs);

	return builder.build();

};

// Utils

function copyItems(from, to) {

    for (var i = 0; i < from.length; i++) {
        if (to.indexOf(from[i]) < 0) {
            to.push(from[i]);
        }
    }

}

function printAstToString(ast, context){
	return ast.print_to_string(context.jsOptions);
}

function toJsString(str) {
	var dq = 0, sq = 0;
	str = str.replace(/[\\\b\f\n\r\t\x22\x27\u2028\u2029\0]/g, function(s){
		switch (s) {
		  case "\\": return "\\\\";
		  case "\b": return "\\b";
		  case "\f": return "\\f";
		  case "\n": return "\\n";
		  case "\r": return "\\r";
		  case "\u2028": return "\\u2028";
		  case "\u2029": return "\\u2029";
		  case '"': ++dq; return '"';
		  case "'": ++sq; return "'";
		  case "\0": return "\\0";
		}
		return s;
	});
	if (dq > sq) return "'" + str.replace(/\x27/g, "\\'") + "'";
	else return '"' + str.replace(/\x22/g, '\\"') + '"';
};
